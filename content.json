{"meta":{"title":"搞搞震iBB","subtitle":"前端博客，爱设计，知识分享，瞎折腾新事物的切图仔","description":"前端，设计，博客，软件，网页","author":"搞搞震iBB","url":"http://180231.xyz","root":"/"},"pages":[{"title":"关于","date":"2020-06-14T07:50:05.506Z","updated":"2020-06-14T07:45:34.817Z","comments":false,"path":"about/index.html","permalink":"http://180231.xyz/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2020-06-15T02:55:28.268Z","updated":"2020-06-12T12:57:41.873Z","comments":false,"path":"books/index.html","permalink":"http://180231.xyz/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-06-14T07:45:35.104Z","updated":"2020-06-14T07:45:35.104Z","comments":false,"path":"categories/index.html","permalink":"http://180231.xyz/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-06-14T09:34:59.000Z","updated":"2020-06-14T09:34:59.694Z","comments":true,"path":"links/index.html","permalink":"http://180231.xyz/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-06-14T09:35:27.000Z","updated":"2020-06-14T09:35:29.326Z","comments":false,"path":"repository/index.html","permalink":"http://180231.xyz/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-06-14T07:50:35.467Z","updated":"2020-06-14T07:45:34.816Z","comments":false,"path":"tags/index.html","permalink":"http://180231.xyz/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"vue学习笔记，持续更新...","slug":"vue学习笔记","date":"2020-12-26T12:34:57.889Z","updated":"2020-12-26T12:36:53.644Z","comments":true,"path":"2020/12/26/vue学习笔记/","link":"","permalink":"http://180231.xyz/2020/12/26/vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"**插值表达式 和 v-text v-text 会替换标签的全部innerText内容， 不会v-cloak 可以使用 v-cloak 指令设置样式，这些样式会在 Vue 实例编译结束时，从绑定的 HTML 元素上被移除。当网络较慢，网页还在加载 Vue.js ，而导致 Vue 来不及渲染，这时页面就会显示出 Vue 源代码。我们可以使用 v-cloak 指令来解决这一问题。v-html 解释html标签v-bind Vue提供的属性绑定机制 缩写是 : 绑定标签的属性v-on Vue提供的事件绑定机制 缩写是 @ 绑定事件函数v-for1、循环数组123&lt;p v-for&#x3D;&quot;(user, i) in list&quot;&gt;Id：&#123;&#123; user.id &#125;&#125; --- 名字：&#123;&#123; user.name &#125;&#125; --- 索引：&#123;&#123;i&#125;&#125;&lt;&#x2F;p&gt;list: [ &#123; id: 1, name: &#39;zs1&#39; &#125;, &#123; id: 2, name: &#39;zs2&#39; &#125;, &#123; id: 3, name: &#39;zs3&#39; &#125;,&#123; id: 4, name: &#39;zs4&#39; &#125; ]list: [1, 2, 3, 4, 5, 6]2、循环对象12345678 &lt;p v-for&#x3D;&quot;(val, key, i) in user&quot;&gt;值是： &#123;&#123; val &#125;&#125; --- 键是： &#123;&#123;key&#125;&#125; -- 索引： &#123;&#123;i&#125;&#125;&lt;&#x2F;p&gt;data: &#123; user: &#123; id: 1, name: &#39;托尼·屎大颗&#39;, gender: &#39;男&#39; &#125; &#125;3、迭代数字1&lt;p v-for&#x3D;&quot;count in 10&quot;&gt;这是第 &#123;&#123; count &#125;&#125; 次循环&lt;&#x2F;p&gt;4、v-for循环时123456789 &lt;!-- 注意： v-for 循环的时候，key 属性只能使用 number获取string --&gt;&lt;!-- 注意： key 在使用的时候，必须使用 v-bind 属性绑定的形式，指定 key 的值 --&gt;&lt;!-- 在组件中，使用v-for循环的时候，或者在一些特殊情况中，如果 v-for 有问题，必须 在使用 v-for 的同时，指定 唯一的 字符串&#x2F;数字 类型 :key 值 --&gt; &lt;p v-for&#x3D;&quot;item in list&quot; :key&#x3D;&quot;item.id&quot;&gt; &lt;input type&#x3D;&quot;checkbox&quot;&gt;&#123;&#123;item.id&#125;&#125; --- &#123;&#123;item.name&#125;&#125; &lt;&#x2F;p&gt;v-if12&lt;h3 v-if&#x3D;&quot;flag&quot;&gt;这是用v-if控制的元素&lt;&#x2F;h3&gt;&lt;h3 v-show&#x3D;&quot;flag&quot;&gt;这是用v-show控制的元素&lt;&#x2F;h3&gt;v-if 的特点：每次都会重新删除或创建元素v-show 的特点： 每次不会重新进行DOM的删除和创建操作，只是切换了元素的 display:none 样式v-if 有较高的切换性能消耗v-show 有较高的初始渲染消耗如果元素涉及到频繁的切换，最好不要使用 v-if, 而是推荐使用 v-show如果元素可能永远也不会被显示出来被用户看到，则推荐使用 v-if注意，v-show 不支持 &lt;template&gt; 元素，也不支持 v-else。v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。样式 v-bind:class v-bind:stylev-bind:class12345678910111213&lt;h1 class&#x3D;&quot;red thin&quot;&gt;这是一个很大很大的H1，大到你无法想象！！！&lt;&#x2F;h1&gt; 第一种使用方式，直接传递一个数组，注意： 这里的 class 需要使用 v-bind 做数据绑定 &lt;!-- &lt;h1 :class&#x3D;&quot;[&#39;thin&#39;, &#39;italic&#39;]&quot;&gt;这是一个很大很大的H1，大到你无法想象！！！&lt;&#x2F;h1&gt; --&gt; &lt;!-- 在数组中使用三元表达式 --&gt; &lt;!-- &lt;h1 :class&#x3D;&quot;[&#39;thin&#39;, &#39;italic&#39;, flag?&#39;active&#39;:&#39;&#39;]&quot;&gt;这是一个很大很大的H1，大到你无法想象！！！&lt;&#x2F;h1&gt; --&gt; &lt;!-- 在数组中使用 对象来代替三元表达式，提高代码的可读性 --&gt; &lt;!-- &lt;h1 :class&#x3D;&quot;[&#39;thin&#39;, &#39;italic&#39;, &#123;&#39;active&#39;:flag&#125; ]&quot;&gt;这是一个很大很大的H1，大到你无法想象！！！&lt;&#x2F;h1&gt; --&gt; &lt;!-- 在为 class 使用 v-bind 绑定 对象的时候，对象的属性是类名，由于 对象的属性可带引号，也可不带引号，所以 这里我没写引号； 属性的值 是一个标识符 --&gt; &lt;h1 :class&#x3D;&quot;classObj&quot;&gt;这是一个很大很大的H1，大到你无法想象！！！&lt;&#x2F;h1&gt; data: &#123; flag: true, classObj: &#123; red: true, thin: true, italic: false, active: false &#125; &#125;v-bind:style123456789&lt;!-- 对象就是无序键值对的集合 --&gt; &lt;!-- &lt;h1 :style&#x3D;&quot;styleObj1&quot;&gt;这是一个h1&lt;&#x2F;h1&gt; --&gt; &lt;h1 :style&#x3D;&quot;[ styleObj1, styleObj2 ]&quot;&gt;这是一个h1&lt;&#x2F;h1&gt; data: &#123; styleObj1: &#123; color: &#39;red&#39;, &#39;font-weight&#39;: 200 &#125;, styleObj2: &#123; &#39;font-style&#39;: &#39;italic&#39; &#125; &#125;事件修饰符1234567891011121314151617181920212223242526272829303132333435&lt;!-- 使用 .stop 阻止冒泡 --&gt; &lt;!-- &lt;div class&#x3D;&quot;inner&quot; @click&#x3D;&quot;div1Handler&quot;&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;戳他&quot; @click.stop&#x3D;&quot;btnHandler&quot;&gt; &lt;&#x2F;div&gt; --&gt; &lt;!-- 使用 .prevent 阻止默认行为 --&gt; &lt;!-- &lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.baidu.com&quot; @click.prevent&#x3D;&quot;linkClick&quot;&gt;有问题，先去百度&lt;&#x2F;a&gt; --&gt; &lt;!-- 使用 .capture 实现捕获触发事件的机制 --&gt; &lt;!-- &lt;div class&#x3D;&quot;inner&quot; @click.capture&#x3D;&quot;div1Handler&quot;&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;戳他&quot; @click&#x3D;&quot;btnHandler&quot;&gt; &lt;&#x2F;div&gt; --&gt; &lt;!-- 使用 .self 实现只有点击当前元素时候，才会触发事件处理函数 --&gt; &lt;!-- &lt;div class&#x3D;&quot;inner&quot; @click.self&#x3D;&quot;div1Handler&quot;&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;戳他&quot; @click&#x3D;&quot;btnHandler&quot;&gt; &lt;&#x2F;div&gt; --&gt; &lt;!-- 使用 .once 只触发一次事件处理函数 --&gt; &lt;!-- &lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.baidu.com&quot; @click.prevent.once&#x3D;&quot;linkClick&quot;&gt;有问题，先去百度&lt;&#x2F;a&gt; --&gt; &lt;!-- 演示： .stop 和 .self 的区别 --&gt; &lt;!-- &lt;div class&#x3D;&quot;outer&quot; @click&#x3D;&quot;div2Handler&quot;&gt; &lt;div class&#x3D;&quot;inner&quot; @click&#x3D;&quot;div1Handler&quot;&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;戳他&quot; @click.stop&#x3D;&quot;btnHandler&quot;&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; --&gt; &lt;!-- .self 只会阻止自己身上冒泡行为的触发，并不会真正阻止 冒泡的行为 --&gt; &lt;!-- &lt;div class&#x3D;&quot;outer&quot; @click&#x3D;&quot;div2Handler&quot;&gt; &lt;div class&#x3D;&quot;inner&quot; @click.self&#x3D;&quot;div1Handler&quot;&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;戳他&quot; @click&#x3D;&quot;btnHandler&quot;&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; --&gt;vue基本指令12345678910111213插值表达式 v-cloak v-text v-html v-bind（缩写是:） v-on（缩写是@） v-model v-for v-if v-show事件修饰符 ： .stop .prevent .capture .self .onceel 指定要控制的区域 data 是个对象，指定了控制的区域内要用到的数据 methods 虽然带个s后缀，但是是个对象，这里可以自定义了方法在 VM 实例中，如果要访问 data 上的数据，或者要访问 methods 中的方法， 必须带 this在 v-for 要会使用 key 属性 （只接受 string &#x2F; number）v-model 只能应用于表单元素在vue中绑定样式两种方式 v-bind:class v-bind:style全局的过滤器 Vue.filter()123456789101112131415 &lt;p&gt;&#123;&#123; msg | msgFormat(&#39;疯狂+1&#39;, &#39;123&#39;) | test &#125;&#125;&lt;&#x2F;p&gt;&#x2F;&#x2F; 定义一个 Vue 全局的过滤器，名字叫做 msgFormat Vue.filter(&#39;msgFormat&#39;, function (msg, arg, arg2) &#123; &#x2F;&#x2F; 字符串的 replace 方法，第一个参数，除了可写一个 字符串之外，还可以定义一个正则 return msg.replace(&#x2F;单纯&#x2F;g, arg + arg2) &#125;) Vue.filter(&#39;test&#39;, function (msg) &#123; return msg + &#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39; &#125;) data: &#123; msg: &#39;曾经，我也是一个单纯的少年，单纯的我，傻傻的问，谁是世界上最单纯的男人&#39; &#125;, 结果：曾经，我也是一个疯狂+1123的少年，疯狂+1123的我，傻傻的问，谁是世界上最疯狂+1123的男人&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;12345678910111213141516171819202122&lt;h3 v-color&#x3D;&quot;&#39;pink&#39;&quot; v-fontweight&#x3D;&quot;900&quot; v-fontsize&#x3D;&quot;50&quot;&gt;&#123;&#123; dt | dateFormat &#125;&#125;&lt;&#x2F;h3&gt; &#x2F;&#x2F; 全局的过滤器， 进行时间的格式化 &#x2F;&#x2F; 所谓的全局过滤器，就是所有的VM实例都共享的 function (dateStr, pattern &#x3D; &quot;&quot;)es6语法，不传参数参数默认&quot;&quot; Vue.filter(&#39;dateFormat&#39;, function (dateStr, pattern &#x3D; &quot;&quot;) &#123; &#x2F;&#x2F; 根据给定的时间字符串，得到特定的时间 var dt &#x3D; new Date(dateStr) &#x2F;&#x2F; yyyy-mm-dd var y &#x3D; dt.getFullYear() var m &#x3D; dt.getMonth() + 1 var d &#x3D; dt.getDate() &#x2F;&#x2F; return y + &#39;-&#39; + m + &#39;-&#39; + d if (pattern.toLowerCase() &#x3D;&#x3D;&#x3D; &#39;yyyy-mm-dd&#39;) &#123; return &#96;$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;&#96; &#125; else &#123; var hh &#x3D; dt.getHours() var mm &#x3D; dt.getMinutes() var ss &#x3D; dt.getSeconds() return &#96;$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;&#96; &#125; &#125;)Vue.directive() 定义全局的指令1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 进到页面马上聚焦到input-search标签上 &lt;!-- 注意： Vue中所有的指令，在调用的时候，都以 v- 开头 --&gt; &lt;input type&#x3D;&quot;text&quot; class&#x3D;&quot;form-control&quot; v-model&#x3D;&quot;keywords&quot; id&#x3D;&quot;search&quot; v-focus v-color&#x3D;&quot;&#39;green&#39;&quot;&gt;&#x2F;&#x2F; 使用 Vue.directive() 定义全局的指令 v-focus &#x2F;&#x2F; 其中：参数1 ： 指令的名称，注意，在定义的时候，指令的名称前面，不需要加 v- 前缀, &#x2F;&#x2F; 但是： 在调用的时候，必须 在指令名称前 加上 v- 前缀来进行调用 &#x2F;&#x2F; 参数2： 是一个对象，这个对象身上，有一些指令相关的函数，这些函数可以在特定的阶段，执行相关的操作 Vue.directive(&#39;focus&#39;, &#123; bind: function (el) &#123; &#x2F;&#x2F; 每当指令绑定到元素上的时候，会立即执行这个 bind 函数，只执行一次 &#x2F;&#x2F; 注意： 在每个 函数中，第一个参数，永远是 el ，表示 被绑定了指令的那个元素，这个 el 参数，是一个原生的JS对象 &#x2F;&#x2F; 在元素 刚绑定了指令的时候，还没有 插入到 DOM中去，这时候，调用 focus 方法没有作用 &#x2F;&#x2F; 因为，一个元素，只有插入DOM之后，才能获取焦点 &#x2F;&#x2F; el.focus() &#125;, inserted: function (el) &#123; &#x2F;&#x2F; inserted 表示元素 插入到DOM中的时候，会执行 inserted 函数【触发1次】 el.focus() &#x2F;&#x2F; 和JS行为有关的操作，最好在 inserted 中去执行，放置 JS行为不生效 &#125;, updated: function (el) &#123; &#x2F;&#x2F; 当VNode更新的时候，会执行 updated， 可能会触发多次 &#125; &#125;) &lt;input type&#x3D;&quot;text&quot; class&#x3D;&quot;form-control&quot; v-model&#x3D;&quot;keywords&quot; id&#x3D;&quot;search&quot; v-focus v-color&#x3D;&quot;&#39;green&#39;&quot;&gt; &#x2F;&#x2F; 自定义一个 设置字体颜色的 指令 Vue.directive(&#39;color&#39;, &#123; &#x2F;&#x2F; 样式，只要通过指令绑定给了元素，不管这个元素有没有被插入到页面中去，这个元素肯定有了一个内联的样式 &#x2F;&#x2F; 将来元素肯定会显示到页面中，这时候，浏览器的渲染引擎必然会解析样式，应用给这个元素 bind: function (el, binding) &#123; &#x2F;&#x2F; el.style.color &#x3D; &#39;red&#39; &#x2F;&#x2F;设计绑定元素指令的颜色 &#x2F;&#x2F; console.log(binding.name) 绑定元素指令的名称 即color &#x2F;&#x2F; 和样式相关的操作，一般都可以在 bind 执行 &#x2F;&#x2F; console.log(binding.value) 绑定元素指令的值 即 green &#x2F;&#x2F; console.log(binding.expression) 绑定元素指令的表示 &#39;green&#39; 打印出来bingding的对象是以下的结果&lt;!-- &#123;name: &quot;color&quot;, rawName: &quot;v-color&quot;, value: &quot;green&quot;, expression: &quot;&#39;green&#39;&quot;, modifiers: &#123;…&#125;, …&#125; def: &#123;bind: ƒ&#125; expression: &quot;&#39;green&#39;&quot; modifiers: &#123;&#125; name: &quot;color&quot; rawName: &quot;v-color&quot; value: &quot;green&quot; __proto__: Object --&gt; el.style.color &#x3D; binding.value &#125; &#125;)生命周期函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 &lt;div id&#x3D;&quot;app&quot;&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;修改msg&quot; @click&#x3D;&quot;msg&#x3D;&#39;No&#39;&quot;&gt; &lt;h3 id&#x3D;&quot;h3&quot;&gt;&#123;&#123; msg &#125;&#125;&lt;&#x2F;h3&gt; &lt;&#x2F;div&gt; var vm &#x3D; new Vue(&#123; el: &#39;#app&#39;, data: &#123; msg: &#39;ok&#39; &#125;, methods: &#123; show() &#123; console.log(&#39;执行了show方法&#39;) &#125; &#125;, beforeCreate() &#123; &#x2F;&#x2F; 这是我们遇到的第一个生命周期函数，表示实例完全被创建出来之前，会执行它 &#x2F;&#x2F; console.log(this.msg) &#x2F;&#x2F; this.show() &#x2F;&#x2F; 注意： 在 beforeCreate 生命周期函数执行的时候，data 和 methods 中的 数据都还没有没初始化 &#125;, created() &#123; &#x2F;&#x2F; 这是遇到的第二个生命周期函数 &#x2F;&#x2F; console.log(this.msg) &#x2F;&#x2F; this.show() &#x2F;&#x2F; 在 created 中，data 和 methods 都已经被初始化好了！ &#x2F;&#x2F; 如果要调用 methods 中的方法，或者操作 data 中的数据，最早，只能在 created 中操作 &#125;, beforeMount() &#123; &#x2F;&#x2F; 这是遇到的第3个生命周期函数，表示 模板已经在内存中编辑完成了，但是尚未把 模板渲染到 页面中 &#x2F;&#x2F; console.log(document.getElementById(&#39;h3&#39;).innerText) &#x2F;&#x2F; 在 beforeMount 执行的时候，页面中的元素，还没有被真正替换过来，只是之前写的一些模板字符串 &#125;, mounted() &#123; &#x2F;&#x2F; 这是遇到的第4个生命周期函数，表示，内存中的模板，已经真实的挂载到了页面中，用户已经可以看到渲染好的页面了 &#x2F;&#x2F; console.log(document.getElementById(&#39;h3&#39;).innerText) &#x2F;&#x2F; 注意： mounted 是 实例创建期间的最后一个生命周期函数，当执行完 mounted 就表示，实例已经被完全创建好了，此时，如果没有其它操作的话，这个实例，就静静的 躺在我们的内存中，一动不动 &#125;, &#x2F;&#x2F; 接下来的是运行中的两个事件 beforeUpdate() &#123; &#x2F;&#x2F; 这时候，表示 我们的界面还没有被更新【数据被更新了吗？ 数据肯定被更新了】 &#x2F;&#x2F; console.log(&#39;界面上元素的内容：&#39; + document.getElementById(&#39;h3&#39;).innerText) &#x2F;&#x2F; console.log(&#39;data 中的 msg 数据是：&#39; + this.msg) &#x2F;&#x2F; 得出结论： 当执行 beforeUpdate 的时候，页面中的显示的数据，还是旧的，此时 data 数据是最新的，页面尚未和 最新的数据保持同步 &#125;, updated() &#123; &#x2F;&#x2F; console.log(&#39;界面上元素的内容：&#39; + document.getElementById(&#39;h3&#39;).innerText) &#x2F;&#x2F; console.log(&#39;data 中的 msg 数据是：&#39; + this.msg) &#x2F;&#x2F; updated 事件执行的时候，页面和 data 数据已经保持同步了，都是最新的 &#125;， beforeDestroy() &#123; &#x2F;&#x2F;当执行beforeDestroy钩子函数的时候。Vue实例就已经从运行阶段，进入到了销毁阶段： 当执行beforeDestroy 的时候。实例身上所有的data和所有的methods，以及过滤器、指令...都处于可用状态。此时，还没有真正执行销毁的过程 &#125;， deatroy() &#123; &#x2F;&#x2F;当执行到destroyed函数的时候。组件经被完全销毁了，此时，组件中所有的据、方法。指令，过滤器...都已经不可用了 &#125; &#125;);12实例生命周期：beforeCreate:在实例初始化之后，数据观测data observer(props、data、computed) 和 event/watcher 事件配置之前被调用。created:实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。beforeMount:在挂载开始之前被调用：相关的 render 函数首次被调用。mounted: el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。beforeUpdate:数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。 你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。updated：无论是组件本身的数据变更，还是从父组件接收到的 props 或者从vuex里面拿到的数据有变更，都会触发虚拟 DOM 重新渲染和打补丁，并在之后调用 updated。beforeDestroy:实例销毁之前调用。在这一步，实例仍然完全可用。destroyed:Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用。注意:created阶段的ajax请求与mounted请求的区别：前者页面视图未出现，如果请求信息过多，页面会长时间处于白屏状态。单个组件的生命周期初始化组件时，仅执行了beforeCreate/Created/beforeMount/mounted四个钩子函数当改变data中定义的变量（响应式变量）时，会执行beforeUpdate/updated钩子函数当切换组件（当前组件未缓存）时，会执行beforeDestory/destroyed钩子函数初始化和销毁时的生命钩子函数均只会执行一次，beforeUpdate/updated可多次执行Vue.nextTick()：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。获取更新后的DOM言外之意就是什么操作需要用到了更新后的DOM而不能使用之前的DOM或者使用更新前的DOM会出问题，所以就衍生出了这个获取更新后的 DOM的Vue方法。所以放在Vue.nextTick()回调函数中的执行的应该是会对DOM进行操作的 js代码，比如Swiper扩展包的:12345678910var swiper = new Swiper('.swiper-container', &#123; pagination: '.swiper-pagination', nextButton: '.swiper-button-next', prevButton: '.swiper-button-prev', paginationClickable: true, spaceBetween: 30, centeredSlides: true, autoplay: 2500, autoplayDisableOnInteraction: false&#125;);什么时候需要用Vue.nextTick():你在Vue生命周期的created()钩子函数进行的DOM操作一定要放在Vue.nextTick()的回调函数中。原因是什么呢，原因是在created()钩子函数执行的时候DOM 其实并未进行任何渲染，而此时进行DOM操作无异于徒劳，所以此处一定要将DOM操作的js代码放进Vue.nextTick()的回调函数中。与之对应的就是mounted钩子函数，因为该钩子函数执行时所有的DOM挂载和渲染都已完成，此时在该钩子函数中进行任何DOM操作都不会有问题 。在数据变化后要执行的某个操作，当你设置 vm.someData = &#39;new value&#39;，DOM并不会马上更新，而是在异步队列被清除，也就是下一个事件循环开始时执行更新时才会进行必要的DOM更新。如果此时你想要根据更新的 DOM 状态去做某些事情，就会出现问题。。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 Vue.nextTick(callback) 。这样回调函数在 DOM 更新完成后就会调用。mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 vm.$nextTick 替换掉 mounted：1234567mounted: function () &#123;this.$nextTick(function () &#123;// Code that will run only after the// entire view has been rendered&#125;)&#125;vue-resource 的基本使用123456789101112131415161718192021222324252627282930313233 &#x2F;&#x2F; 如果我们通过全局配置了，请求的数据接口 根域名，则 ，在每次单独发起 http 请求的时候，请求的 url 路径，应该以相对路径开头，前面不能带 &#x2F; ，否则 不会启用根路径做拼接； Vue.http.options.root &#x3D; &#39;http:&#x2F;&#x2F;vue.studyit.io&#x2F;&#39;; &#x2F;&#x2F; 全局启用 emulateJSON 选项 Vue.http.options.emulateJSON &#x3D; true;var vm &#x3D; new Vue(&#123; el: &#39;#app&#39;, data: &#123;&#125;, methods: &#123; getInfo() &#123; &#x2F;&#x2F; 发起get请求 &#x2F;&#x2F; 当发起get请求之后， 通过 .then 来设置成功的回调函数 this.$http.get(&#39;https:&#x2F;&#x2F;jsonplaceholder.typicode.com&#x2F;posts&#x2F;1&#39;).then(function (result) &#123; &#x2F;&#x2F; 通过 result.body 拿到服务器返回的成功的数据 console.log(result.body) &#125;) &#125;, postInfo() &#123; &#x2F;&#x2F; 发起 post 请求 application&#x2F;x-wwww-form-urlencoded &#x2F;&#x2F; 手动发起的 Post 请求，默认没有表单格式，所以，有的服务器处理不了 &#x2F;&#x2F; 通过 post 方法的第三个参数， &#123; emulateJSON: true &#125; 设置 提交的内容类型 为 普通表单数据格式 this.$http.post(&#39;http:&#x2F;&#x2F;jsonplaceholder.typicode.com&#x2F;posts&#39;, &#123;&#125;, &#123; emulateJSON: true &#125;) .then(result &#x3D;&gt; &#123; console.log(result.body) &#125;) &#125;, jsonpInfo() &#123; &#x2F;&#x2F; 发起JSONP 请求 this.$http.jsonp(&#39;https:&#x2F;&#x2F;jsonplaceholder.typicode.com&#x2F;posts&#x2F;1&#39;).then(result &#x3D;&gt; &#123; console.log(result.body) &#125;) &#125; &#125; &#125;);JSONP的实现原理由于浏览器的安全性限制，不允许AJAX访问 协议不同、域名不同、端口号不同的 数据接口，浏览器认为这种访问不安全；可以通过动态创建script标签的形式，把script标签的src属性，指向数据接口的地址，因为script标签不存在跨域限制，这种数据获取方式，称作JSONP（注意：根据JSONP的实现原理，知晓，JSONP只支持Get请求）；具体实现过程：先在客户端定义一个回调方法，预定义对数据的操作；再把这个回调方法的名称，通过URL传参的形式，提交到服务器的数据接口；服务器数据接口组织好要发送给客户端的数据，再拿着客户端传递过来的回调方法名称，拼接出一个调用这个方法的字符串，发送给客户端去解析执行；客户端拿到服务器返回的字符串之后，当作Script脚本去解析执行，这样就能够拿到JSONP的数据了；带大家通过 Node.js ，来手动实现一个JSONP的请求例子；1234567891011121314151617181920212223242526272829303132333435const http &#x3D; require(&#39;http&#39;);&#x2F;&#x2F; 导入解析 URL 地址的核心模块const urlModule &#x3D; require(&#39;url&#39;);const server &#x3D; http.createServer();&#x2F;&#x2F; 监听 服务器的 request 请求事件，处理每个请求server.on(&#39;request&#39;, (req, res) &#x3D;&gt; &#123; const url &#x3D; req.url; &#x2F;&#x2F; 解析客户端请求的URL地址 var info &#x3D; urlModule.parse(url, true); &#x2F;&#x2F; 如果请求的 URL 地址是 &#x2F;getjsonp ，则表示要获取JSONP类型的数据 if (info.pathname &#x3D;&#x3D;&#x3D; &#39;&#x2F;getjsonp&#39;) &#123; &#x2F;&#x2F; 获取客户端指定的回调函数的名称 var cbName &#x3D; info.query.callback; &#x2F;&#x2F; 手动拼接要返回给客户端的数据对象 var data &#x3D; &#123; name: &#39;zs&#39;, age: 22, gender: &#39;男&#39;, hobby: [&#39;吃饭&#39;, &#39;睡觉&#39;, &#39;运动&#39;] &#125; &#x2F;&#x2F; 拼接出一个方法的调用，在调用这个方法的时候，把要发送给客户端的数据，序列化为字符串，作为参数传递给这个调用的方法： var result &#x3D; &#96;$&#123;cbName&#125;($&#123;JSON.stringify(data)&#125;)&#96;; &#x2F;&#x2F; 将拼接好的方法的调用，返回给客户端去解析执行 res.end(result); &#125; else &#123; res.end(&#39;404&#39;); &#125;&#125;);server.listen(3000, () &#x3D;&gt; &#123; console.log(&#39;server running at http:&#x2F;&#x2F;127.0.0.1:3000&#39;);&#125;);vue-resource 的配置步骤：直接在页面中，通过script标签，引入 vue-resource 的脚本文件；注意：引用的先后顺序是：先引用 Vue 的脚本文件，再引用 vue-resource 的脚本文件；发送get请求：12345getInfo() &#123; &#x2F;&#x2F; get 方式获取数据 this.$http.get(&#39;http:&#x2F;&#x2F;127.0.0.1:8899&#x2F;api&#x2F;getlunbo&#39;).then(res &#x3D;&gt; &#123; console.log(res.body); &#125;)&#125;发送post请求：12345678910postInfo() &#123; var url &#x3D; &#39;http:&#x2F;&#x2F;127.0.0.1:8899&#x2F;api&#x2F;post&#39;; &#x2F;&#x2F; post 方法接收三个参数： &#x2F;&#x2F; 参数1： 要请求的URL地址 &#x2F;&#x2F; 参数2： 要发送的数据对象 &#x2F;&#x2F; 参数3： 指定post提交的编码类型为 application&#x2F;x-www-form-urlencoded this.$http.post(url, &#123; name: &#39;zs&#39; &#125;, &#123; emulateJSON: true &#125;).then(res &#x3D;&gt; &#123; console.log(res.body); &#125;);&#125;发送JSONP请求获取数据：123456jsonpInfo() &#123; &#x2F;&#x2F; JSONP形式从服务器获取数据 var url &#x3D; &#39;http:&#x2F;&#x2F;127.0.0.1:8899&#x2F;api&#x2F;jsonp&#39;; this.$http.jsonp(url).then(res &#x3D;&gt; &#123; console.log(res.body); &#125;);&#125;vue动画.v-enter 进入动画时候.v-enter-active 进入动画过程中.v-enter-to 进入动画进行到最后.v-leave 这个没有实际意义,为了美感.v-leave-active 离开动画过程中.v-leave-to 离开动画结束12345678910111213141516171819&#x2F;* v-enter 【这是一个时间点】 是进入之前，元素的起始状态，此时还没有开始进入 *&#x2F; &#x2F;* v-leave-to 【这是一个时间点】 是动画离开之后，离开的终止状态，此时，元素 动画已经结束了 *&#x2F; .v-enter, .v-leave-to &#123; opacity: 0; transform: translateX(150px); &#125; &#x2F;* v-enter-active 【入场动画的时间段】 *&#x2F; &#x2F;* v-leave-active 【离场动画的时间段】 *&#x2F; .v-enter-active, .v-leave-active&#123; transition: all 0.8s ease; &#125; &lt;!-- transition 元素，是 Vue 官方提供的 --&gt; &lt;transition&gt; &lt;h3 v-if&#x3D;&quot;flag&quot;&gt;这是一个H3&lt;&#x2F;h3&gt; &lt;&#x2F;transition&gt;定义DOM结构，其中，需要使用 transition-group 组件把v-for循环的列表包裹起来：123456789&lt;!-- 在实现列表过渡的时候，如果需要过渡的元素，是通过 v-for 循环渲染出来的，不能使用 transition 包裹，需要使用 transitionGroup --&gt; &lt;!-- 如果要为 v-for 循环创建的元素设置动画，必须为每一个 元素 设置 :key 属性 --&gt; &lt;!-- 给 ransition-group 添加 appear 属性，实现页面刚展示出来时候，入场时候的效果 --&gt; &lt;!-- 通过 为 transition-group 元素，设置 tag 属性，指定 transition-group 渲染为指定的元素，如果不指定 tag 属性，默认，渲染为 span 标签 --&gt; &lt;transition-group appear tag&#x3D;&quot;ul&quot;&gt; &lt;li v-for&#x3D;&quot;(item, i) in list&quot; :key&#x3D;&quot;item.id&quot; @click&#x3D;&quot;del(i)&quot;&gt; &#123;&#123;item.id&#125;&#125; --- &#123;&#123;item.name&#125;&#125; &lt;&#x2F;li&gt; &lt;&#x2F;transition-group&gt;修下动画v前缀，自定义动画1234567891011121314.my-enter, .my-leave-to &#123; opacity: 0; transform: translateY(70px); &#125; .my-enter-active, .my-leave-active&#123; transition: all 0.8s ease; &#125; &lt;transition name&#x3D;&quot;my&quot;&gt; &lt;h6 v-if&#x3D;&quot;flag2&quot;&gt;这是一个H6&lt;&#x2F;h6&gt; &lt;&#x2F;transition&gt;动画组与上一个不一样的是，这个数多组动画。区别 使用了 transition-group动画名称enter-classenter-active-classenter-to-class (2.1.8+)leave-classleave-active-classleave-to-class (2.1.8+)第三方库实现动画12345678910 &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;.&#x2F;lib&#x2F;animate.css&quot;&gt;&lt;!-- 入场 bounceIn 离场 bounceOut --&gt;&lt;!-- 使用 :duration&#x3D;&quot;&#123; enter: 200, leave: 400 &#125;&quot; 来分别设置 入场的时长 和 离场的时长 --&gt; &lt;transition enter-active-class&#x3D;&quot;bounceIn&quot; leave-active-class&#x3D;&quot;bounceOut&quot; :duration&#x3D;&quot;&#123; enter: 200, leave: 400 &#125;&quot;&gt; &lt;h3 v-if&#x3D;&quot;flag&quot; class&#x3D;&quot;animated&quot;&gt;这是一个H3&lt;&#x2F;h3&gt; &lt;&#x2F;transition&gt;使用钩子函数实现动画半场效果123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;div id&#x3D;&quot;app&quot;&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;快到碗里来&quot; @click&#x3D;&quot;flag&#x3D;!flag&quot;&gt; &lt;!-- 1. 使用 transition 元素把 小球包裹起来 --&gt; &lt;transition @before-enter&#x3D;&quot;beforeEnter&quot; @enter&#x3D;&quot;enter&quot; @after-enter&#x3D;&quot;afterEnter&quot;&gt; &lt;div class&#x3D;&quot;ball&quot; v-show&#x3D;&quot;flag&quot;&gt;&lt;&#x2F;div&gt; &lt;&#x2F;transition&gt; &lt;&#x2F;div&gt; &lt;script&gt; &#x2F;&#x2F; 创建 Vue 实例，得到 ViewModel var vm &#x3D; new Vue(&#123; el: &#39;#app&#39;, data: &#123; flag: false &#125;, methods: &#123; &#x2F;&#x2F; 注意： 动画钩子函数的第一个参数：el，表示 要执行动画的那个DOM元素，是个原生的 JS DOM对象 &#x2F;&#x2F; 大家可以认为 ， el 是通过 document.getElementById(&#39;&#39;) 方式获取到的原生JS DOM对象 beforeEnter(el)&#123; &#x2F;&#x2F; beforeEnter 表示动画入场之前，此时，动画尚未开始，可以 在 beforeEnter 中，设置元素开始动画之前的起始样式 &#x2F;&#x2F; 设置小球开始动画之前的，起始位置 el.style.transform &#x3D; &quot;translate(0, 0)&quot; &#125;, enter(el, done)&#123; &#x2F;&#x2F; 这句话，没有实际的作用，但是，如果不写，出不来动画效果； &#x2F;&#x2F; 可以认为 el.offsetWidth 会强制动画刷新 el.offsetWidth &#x2F;&#x2F; enter 表示动画 开始之后的样式，这里，可以设置小球完成动画之后的，结束状态 el.style.transform &#x3D; &quot;translate(150px, 450px)&quot; el.style.transition &#x3D; &#39;all 1s ease&#39; &#x2F;&#x2F; this.flag &#x3D; !this.flag &#x2F;&#x2F; 这里的 done， 起始就是 afterEnter 这个函数，也就是说：done 是 afterEnter 函数的引用 done() &#125;, afterEnter(el)&#123; &#x2F;&#x2F; 动画完成之后，会调用 afterEnter this.flag &#x3D; !this.flag &#x2F;&#x2F; console.log(&#39;ok&#39;) &#x2F;&#x2F; this.flag &#x3D; !this.flag &#125; &#125; &#125;);vue组件化定义Vue组件什么是组件： 组件的出现，就是为了拆分Vue实例的代码量的，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样的功能，就可以去调用对应的组件即可；组件化和模块化的不同：模块化： 是从代码逻辑的角度进行划分的；方便代码分层开发，保证每个功能模块的职能单一；组件化： 是从UI界面的角度进行划分的；前端的组件化，方便UI组件的重用；全局组件定义的三种方式使用 Vue.extend 配合 Vue.component 方法：1234var login &#x3D; Vue.extend(&#123; template: &#39;&lt;h1&gt;登录&lt;&#x2F;h1&gt;&#39; &#125;); Vue.component(&#39;login&#39;, login);直接使用 Vue.component 方法：123Vue.component(&#39;register&#39;, &#123; template: &#39;&lt;h1&gt;注册&lt;&#x2F;h1&gt;&#39; &#125;);将模板字符串，定义到script标签种：123&lt;script id&#x3D;&quot;tmpl&quot; type&#x3D;&quot;x-template&quot;&gt; &lt;div&gt;&lt;a href&#x3D;&quot;#&quot;&gt;登录&lt;&#x2F;a&gt; | &lt;a href&#x3D;&quot;#&quot;&gt;注册&lt;&#x2F;a&gt;&lt;&#x2F;div&gt; &lt;&#x2F;script&gt;同时，需要使用 Vue.component 来定义组件：123Vue.component(&#39;account&#39;, &#123; template: &#39;#tmpl&#39; &#125;);注意： 组件中的DOM结构，有且只能有唯一的根元素（Root Element）来进行包裹！组件可以有自己的 data 数据1234567891011&#x2F;&#x2F; 2. 组件的 data 和 实例的 data 有点不一样,实例中的 data 可以为一个对象,但是 组件中的 data 必须是一个方法&#x2F;&#x2F; 3. 组件中的 data 除了必须为一个方法之外,这个方法内部,还必须返回一个对象才行;&#x2F;&#x2F; 4. 组件中 的data 数据,使用方式,和实例中的 data 使用方式完全一样!!!Vue.component(&#39;mycom1&#39;, &#123; template: &#39;&lt;h1&gt;这是全局组件 --- &#123;&#123;msg&#125;&#125;&lt;&#x2F;h1&gt;&#39;, data: function () &#123; return &#123; msg: &#39;这是组件的中data定义的数据&#39; &#125; &#125;&#125;)使用flag标识符结合v-if和v-else切换组件页面结构：12345&lt;div id&#x3D;&quot;app&quot;&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;toggle&quot; @click&#x3D;&quot;flag&#x3D;!flag&quot;&gt; &lt;my-com1 v-if&#x3D;&quot;flag&quot;&gt;&lt;&#x2F;my-com1&gt; &lt;my-com2 v-else&#x3D;&quot;flag&quot;&gt;&lt;&#x2F;my-com2&gt; &lt;&#x2F;div&gt;Vue实例定义：123456789101112131415161718&lt;script&gt; Vue.component(&#39;myCom1&#39;, &#123; template: &#39;&lt;h3&gt;奔波霸&lt;&#x2F;h3&gt;&#39; &#125;) Vue.component(&#39;myCom2&#39;, &#123; template: &#39;&lt;h3&gt;霸波奔&lt;&#x2F;h3&gt;&#39; &#125;) &#x2F;&#x2F; 创建 Vue 实例，得到 ViewModel var vm &#x3D; new Vue(&#123; el: &#39;#app&#39;, data: &#123; flag: true &#125;, methods: &#123;&#125; &#125;); &lt;&#x2F;script&gt;使用:is属性来切换不同的子组件,并添加切换动画（实现动态组件）组件实例定义方式：12345678910111213141516171819202122&#x2F;&#x2F; 登录组件 const login &#x3D; Vue.extend(&#123; template: &#96;&lt;div&gt; &lt;h3&gt;登录组件&lt;&#x2F;h3&gt; &lt;&#x2F;div&gt;&#96; &#125;); Vue.component(&#39;login&#39;, login); &#x2F;&#x2F; 注册组件 const register &#x3D; Vue.extend(&#123; template: &#96;&lt;div&gt; &lt;h3&gt;注册组件&lt;&#x2F;h3&gt; &lt;&#x2F;div&gt;&#96; &#125;); Vue.component(&#39;register&#39;, register); &#x2F;&#x2F; 创建 Vue 实例，得到 ViewModel var vm &#x3D; new Vue(&#123; el: &#39;#app&#39;, data: &#123; comName: &#39;login&#39; &#125;, methods: &#123;&#125; &#125;);使用component标签，来引用组件，并通过:is属性来指定要加载的组件：12345678&lt;div id&#x3D;&quot;app&quot;&gt; &lt;a href&#x3D;&quot;#&quot; @click.prevent&#x3D;&quot;comName&#x3D;&#39;login&#39;&quot;&gt;登录&lt;&#x2F;a&gt; &lt;a href&#x3D;&quot;#&quot; @click.prevent&#x3D;&quot;comName&#x3D;&#39;register&#39;&quot;&gt;注册&lt;&#x2F;a&gt; &lt;hr&gt; &lt;transition mode&#x3D;&quot;out-in&quot;&gt; &lt;component :is&#x3D;&quot;comName&quot;&gt;&lt;&#x2F;component&gt; &lt;&#x2F;transition&gt;&lt;&#x2F;div&gt;添加切换样式：1234567891011121314151617&lt;style&gt; .v-enter, .v-leave-to &#123; opacity: 0; transform: translateX(30px); &#125; .v-enter-active, .v-leave-active &#123; position: absolute; transition: all 0.3s ease; &#125; h3&#123; margin: 0; &#125;&lt;&#x2F;style&gt;定义组件推荐方式1234567891011121314&lt;div id&#x3D;&quot;app&quot;&gt; &lt;!-- &lt;mylogin&gt;&lt;&#x2F;mylogin&gt; --&gt; &lt;login&gt;&lt;&#x2F;login&gt; &lt;&#x2F;div&gt;&#x2F;&#x2F; 通过 对象 字面量的形式， 定义了一个 组件模板对象 var login &#x3D; &#123; template: &#39;&lt;h1 &gt;1234&lt;&#x2F;h1&gt;&#39; &#125; components: &#123; &#x2F;&#x2F; &#39;组件的名称&#39;: 组件的模板对象 &#x2F;&#x2F; &#39;mylogin&#39;: login login &#125;父组件向子组件传值1234567891011121314151617181920使用v-bind或简化指令，将数据传递到子组件中：&lt;div id&#x3D;&quot;app&quot;&gt; &lt;son :finfo&#x3D;&quot;msg&quot;&gt;&lt;&#x2F;son&gt; &lt;&#x2F;div&gt; 组件实例定义方式，注意：一定要使用props属性来定义父组件传递过来的数据 &lt;script&gt; &#x2F;&#x2F; 创建 Vue 实例，得到 ViewModel var vm &#x3D; new Vue(&#123; el: &#39;#app&#39;, data: &#123; msg: &#39;这是父组件中的消息&#39; &#125;, components: &#123; son: &#123; template: &#39;&lt;h1&gt;这是子组件 --- &#123;&#123;finfo&#125;&#125;&lt;&#x2F;h1&gt;&#39;, props: [&#39;finfo&#39;] &#x2F;&#x2F;finfo相当于子组件中data的属性 &#125; &#125; &#125;); &lt;&#x2F;script&gt;子组件向父组件传值原理：父组件将方法的引用，传递到子组件内部，子组件在内部调用父组件传递过来的方法，同时把要发送给父组件的数据，在调用方法的时候当作参数传递进去；父组件将方法的引用传递给子组件，其中，getMsg是父组件中methods中定义的方法名称，func是子组件调用传递过来方法时候的方法名称1&lt;son @func&#x3D;&quot;getMsg&quot;&gt;&lt;&#x2F;son&gt;子组件内部通过this.$emit(&#39;方法名&#39;, 要传递的数据)方式，来调用父组件中的方法，同时把数据传递给父组件使用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;div id&#x3D;&quot;app&quot;&gt; &lt;!-- 父组件向子组件 传递 方法，使用的是 事件绑定机制； v-on, 当我们自定义了 一个 事件属性之后，那么，子组件就能够，通过某些方式，来调用 传递进去的 这个 方法了 --&gt; &lt;com2 @func&#x3D;&quot;show&quot;&gt;&lt;&#x2F;com2&gt; &lt;template id&#x3D;&quot;tmpl&quot;&gt; &lt;div&gt; &lt;h1&gt;这是 子组件&lt;&#x2F;h1&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;这是子组件中的按钮 - 点击它，触发 父组件传递过来的 func 方法&quot; @click&#x3D;&quot;myclick&quot;&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; var com2 &#x3D; &#123; template: &#39;#tmpl&#39;, &#x2F;&#x2F; 通过指定了一个 Id, 表示 说，要去加载 这个指定Id的 template 元素中的内容，当作 组件的HTML结构 data() &#123; return &#123; sonmsg: &#123; name: &#39;小头儿子&#39;, age: 6 &#125; &#125; &#125;, methods: &#123; myclick() &#123; &#x2F;&#x2F; 当点击子组件的按钮的时候，如何 拿到 父组件传递过来的 func 方法，并调用这个方法？？？ &#x2F;&#x2F; emit 英文原意： 是触发，调用、发射的意思 &#x2F;&#x2F; this.$emit(&#39;func123&#39;, 123, 456) this.$emit(&#39;func&#39;, this.sonmsg) &#125; &#125; &#125; &#x2F;&#x2F; 创建 Vue 实例，得到 ViewModel var vm &#x3D; new Vue(&#123; el: &#39;#app&#39;, data: &#123; datamsgFormSon: null &#125;, methods: &#123; show(data) &#123; &#x2F;&#x2F; console.log(&#39;调用了父组件身上的 show 方法: --- &#39; + data) &#x2F;&#x2F; console.log(data); this.datamsgFormSon &#x3D; data &#125; &#125;, components: &#123; com2 &#x2F;&#x2F; com2: com2 &#125; &#125;); &lt;&#x2F;script&gt;使用 this.$refs 来获取元素和组件可以访问子组件实例和子元素（$refs只会在组件渲染完成之后生效，并且它们不是响应式的。这仅作为一个用于直接操作子组件的“逃生舱”——你应该避免在模板或计算属性中访问$refs）123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;div id&#x3D;&quot;app&quot;&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;获取元素&quot; @click&#x3D;&quot;getElement&quot; ref&#x3D;&quot;mybtn&quot;&gt; &lt;h3 id&#x3D;&quot;myh3&quot; ref&#x3D;&quot;myh3&quot;&gt;哈哈哈， 今天天气太好了！！！&lt;&#x2F;h3&gt; &lt;hr&gt; &lt;login ref&#x3D;&quot;mylogin&quot;&gt;&lt;&#x2F;login&gt; &lt;&#x2F;div&gt; &lt;script&gt; var login &#x3D; &#123; template: &#39;&lt;h1&gt;登录组件&lt;&#x2F;h1&gt;&#39;, data() &#123; return &#123; msg: &#39;son msg&#39; &#125; &#125;, methods: &#123; show() &#123; console.log(&#39;调用了子组件的方法&#39;) &#x2F;&#x2F; console.log(this.$refs.mgh3.innerText); &#125; &#125; &#125; &#x2F;&#x2F; 创建 Vue 实例，得到 ViewModel var vm &#x3D; new Vue(&#123; el: &#39;#app&#39;, data: &#123;&#125;, methods: &#123; getElement() &#123; &#x2F;&#x2F; console.log(document.getElementById(&#39;myh3&#39;).innerText) &#x2F;&#x2F; ref 是 英文单词 【reference】 值类型 和 引用类型 referenceError &#x2F;&#x2F; console.log(this.$refs.myh3.innerText) console.log(this.$refs.mylogin.msg) this.$refs.mylogin.show() &#125; &#125;, components: &#123; login &#125; &#125;); &lt;&#x2F;script&gt;vue-router在 vue 中使用 vue-router导入 vue-router 组件类库：12&lt;!-- 1. 导入 vue-router 组件类库 --&gt; &lt;script src&#x3D;&quot;.&#x2F;lib&#x2F;vue-router-2.7.0.js&quot;&gt;&lt;&#x2F;script&gt;使用 router-link 组件来导航什么是路由后端路由：对于普通的网站，所有的超链接都是URL地址，所有的URL地址都对应服务器上对应的资源；前端路由：对于单页面应用程序来说，主要通过URL中的hash(#号)来实现不同页面之间的切换，同时，hash有一个特点：HTTP请求中不会包含hash相关的内容；所以，单页面程序中的页面跳转主要用hash实现；在单页面应用程序中，这种通过hash改变来切换页面的方式，称作前端路由（区别于后端路由）；；1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 .router-link-active, .myactive &#123; color: red; font-weight: 800; font-style: italic; font-size: 80px; text-decoration: underline; background-color: green; &#125;&lt;!-- router-link 默认渲染为一个a 标签 tag设计标签--&gt; &#x2F;&#x2F;使用tag属性指定router-link渲染的标签类型 &lt;router-link to&#x3D;&quot;&#x2F;login&quot;&quot; tag&#x3D;&quot;span&quot; &gt;登录&lt;&#x2F;router-link&gt; &lt;router-link to&#x3D;&quot;&#x2F;register&quot;&gt;注册&lt;&#x2F;router-link&gt; &lt;!-- 这是 vue-router 提供的元素，专门用来 当作占位符的，将来，路由规则，匹配到的组件，就会展示到这个 router-view 中去 --&gt; &lt;!-- 所以： 我们可以把 router-view 认为是一个占位符 --&gt; &lt;transition mode&#x3D;&quot;out-in&quot;&gt; &lt;router-view&gt;&lt;&#x2F;router-view&gt; &lt;&#x2F;transition&gt; &lt;script&gt; &#x2F;&#x2F; 组件的模板对象 var login &#x3D; &#123; template: &#39;&lt;h1&gt;登录组件&lt;&#x2F;h1&gt;&#39; &#125; var register &#x3D; &#123; template: &#39;&lt;h1&gt;注册组件&lt;&#x2F;h1&gt;&#39; &#125; &#x2F;&#x2F; 2. 创建一个路由对象， 当 导入 vue-router 包之后，在 window 全局对象中，就有了一个 路由的构造函数，叫做 VueRouter &#x2F;&#x2F; 在 new 路由对象的时候，可以为 构造函数，传递一个配置对象 var routerObj &#x3D; new VueRouter(&#123; &#x2F;&#x2F; route &#x2F;&#x2F; 这个配置对象中的 route 表示 【路由匹配规则】 的意思 routes: [ &#x2F;&#x2F; 路由匹配规则 &#x2F;&#x2F; 每个路由规则，都是一个对象，这个规则对象，身上，有两个必须的属性： &#x2F;&#x2F; 属性1 是 path， 表示监听 哪个路由链接地址； &#x2F;&#x2F; 属性2 是 component， 表示，如果 路由是前面匹配到的 path ，则展示 component 属性对应的那个组件 &#x2F;&#x2F; 注意： component 的属性值，必须是一个 组件的模板对象， 不能是 组件的引用名称； &#x2F;&#x2F; &#123; path: &#39;&#x2F;&#39;, component: login &#125;, &#123; path: &#39;&#x2F;&#39;, redirect: &#39;&#x2F;login&#39; &#125;, &#x2F;&#x2F; 这里的 redirect 和 Node 中的 redirect 完全是两码事 &#123; path: &#39;&#x2F;login&#39;, component: login &#125;, &#123; path: &#39;&#x2F;register&#39;, component: register &#125; ], linkActiveClass: &#39;myactive&#39; 默认的router-link的有class&#x3D;&quot;router-link-exact-active router-link-active&quot; 设置后class&#x3D;&quot;router-link-exact-active myactive&quot; 之后可以自定义路由链接的样式了 &#125;) &#x2F;&#x2F; 创建 Vue 实例，得到 ViewModel var vm &#x3D; new Vue(&#123; el: &#39;#app&#39;, data: &#123;&#125;, methods: &#123;&#125;, router: routerObj &#x2F;&#x2F; 将路由规则对象，注册到 vm 实例上，用来监听 URL 地址的变化，然后展示对应的组件 &#125;);路由规则传递参数两种方式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;div id&#x3D;&quot;app&quot;&gt; 方式一 &lt;!-- 如果在路由中，使用 查询字符串，给路由传递参数，则 不需要修改 路由规则的 path 属性 --&gt; &lt;router-link to&#x3D;&quot;&#x2F;login?id&#x3D;10&amp;name&#x3D;zs&quot;&gt;登录&lt;&#x2F;router-link&gt; &lt;router-link to&#x3D;&quot;&#x2F;register&quot;&gt;注册&lt;&#x2F;router-link&gt; &lt;router-view&gt;&lt;&#x2F;router-view&gt; 方式二 &lt;!-- 如果在路由中，使用 查询字符串，给路由传递参数，则 不需要修改 路由规则的 path 属性 --&gt; &lt;router-link to&#x3D;&quot;&#x2F;login&#x2F;12&#x2F;ls&quot;&gt;登录&lt;&#x2F;router-link&gt; &lt;router-link to&#x3D;&quot;&#x2F;register&quot;&gt;注册&lt;&#x2F;router-link&gt; &lt;router-view&gt;&lt;&#x2F;router-view&gt; &lt;&#x2F;div&gt; &lt;script&gt; var login &#x3D; &#123; 方式一 template: &#39;&lt;h1&gt;登录 --- &#123;&#123; $route.query.id &#125;&#125; --- &#123;&#123; $route.query.name &#125;&#125;&lt;&#x2F;h1&gt;&#39;, 方式二 template: &#39;&lt;h1&gt;登录 --- &#123;&#123; $route.params.id &#125;&#125; --- &#123;&#123; $route.params.name &#125;&#125;&lt;&#x2F;h1&gt;&#39;, data()&#123; return &#123; msg: &#39;123&#39; &#125; &#125;, created()&#123; &#x2F;&#x2F; 组件的生命周期钩子函数 console.log(this.$route.params.id) &#125; &#125; var register &#x3D; &#123; template: &#39;&lt;h1&gt;注册&lt;&#x2F;h1&gt;&#39; &#125; var router &#x3D; new VueRouter(&#123; 方式一 routes: [ &#123; path: &#39;&#x2F;login&#39;, component: login &#125;, &#123; path: &#39;&#x2F;register&#39;, component: register &#125; ] 方式二 routes: [ &#123; path: &#39;&#x2F;login&#x2F;:id&#x2F;:name&#39;, component: login &#125;, &#123; path: &#39;&#x2F;register&#39;, component: register &#125; ] &#125;) &#x2F;&#x2F; 创建 Vue 实例，得到 ViewModel var vm &#x3D; new Vue(&#123; el: &#39;#app&#39;, data: &#123;&#125;, methods: &#123;&#125;, &#x2F;&#x2F; router: router router &#125;); &lt;&#x2F;script&gt;路由嵌套12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;div id&#x3D;&quot;app&quot;&gt; &lt;router-link to&#x3D;&quot;&#x2F;account&quot;&gt;Account&lt;&#x2F;router-link&gt; &lt;router-view&gt;&lt;&#x2F;router-view&gt; &lt;&#x2F;div&gt; &lt;template id&#x3D;&quot;tmpl&quot;&gt; &lt;div&gt; &lt;h1&gt;这是 Account 组件&lt;&#x2F;h1&gt; &lt;router-link to&#x3D;&quot;&#x2F;account&#x2F;login&quot;&gt;登录&lt;&#x2F;router-link&gt; &lt;router-link to&#x3D;&quot;&#x2F;account&#x2F;register&quot;&gt;注册&lt;&#x2F;router-link&gt; &lt;router-view&gt;&lt;&#x2F;router-view&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; &#x2F;&#x2F; 组件的模板对象 var account &#x3D; &#123; template: &#39;#tmpl&#39; &#125; var login &#x3D; &#123; template: &#39;&lt;h3&gt;登录&lt;&#x2F;h3&gt;&#39; &#125; var register &#x3D; &#123; template: &#39;&lt;h3&gt;注册&lt;&#x2F;h3&gt;&#39; &#125; var router &#x3D; new VueRouter(&#123; routes: [ &#123; path: &#39;&#x2F;account&#39;, component: account, &#x2F;&#x2F; 使用 children 属性，实现子路由，同时，子路由的 path 前面，不要带 &#x2F; ，否则永远以根路径开始请求，这样不方便我们用户去理解URL地址 children: [ &#123; path: &#39;login&#39;, component: login &#125;, &#123; path: &#39;register&#39;, component: register &#125; ] &#125; &#x2F;&#x2F; &#123; path: &#39;&#x2F;account&#x2F;login&#39;, component: login &#125;, &#x2F;&#x2F; &#123; path: &#39;&#x2F;account&#x2F;register&#39;, component: register &#125; ] &#125;) &#x2F;&#x2F; 创建 Vue 实例，得到 ViewModel var vm &#x3D; new Vue(&#123; el: &#39;#app&#39;, data: &#123;&#125;, methods: &#123;&#125;, router &#125;); &lt;&#x2F;script&gt;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;div id&#x3D;&quot;app&quot;&gt; &lt;router-view&gt;&lt;&#x2F;router-view&gt; &lt;div class&#x3D;&quot;container&quot;&gt; &lt;router-view name&#x3D;&quot;left&quot;&gt;&lt;&#x2F;router-view&gt; &lt;router-view name&#x3D;&quot;main&quot;&gt;&lt;&#x2F;router-view&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;script&gt; var header &#x3D; &#123; template: &#39;&lt;h1 class&#x3D;&quot;header&quot;&gt;Header头部区域&lt;&#x2F;h1&gt;&#39; &#125; var leftBox &#x3D; &#123; template: &#39;&lt;h1 class&#x3D;&quot;left&quot;&gt;Left侧边栏区域&lt;&#x2F;h1&gt;&#39; &#125; var mainBox &#x3D; &#123; template: &#39;&lt;h1 class&#x3D;&quot;main&quot;&gt;mainBox主体区域&lt;&#x2F;h1&gt;&#39; &#125; &#x2F;&#x2F; 创建路由对象 var router &#x3D; new VueRouter(&#123; routes: [ &#x2F;* &#123; path: &#39;&#x2F;&#39;, component: header &#125;, &#123; path: &#39;&#x2F;left&#39;, component: leftBox &#125;, &#123; path: &#39;&#x2F;main&#39;, component: mainBox &#125; *&#x2F; &#123; path: &#39;&#x2F;&#39;, components: &#123; &#39;default&#39;: header, 组件的第一个属性是标签的名称，第二个参数header代表对象。默认代表什么&lt;router-view&gt;&lt;&#x2F;router-view&gt; &#39;left&#39;: leftBox, 第一个参数是标签的名称即name属性&lt;router-view name&#x3D;&quot;left&quot;&gt;&lt;&#x2F;router-view&gt; &#39;main&#39;: mainBox &#125; &#125; ] &#125;) &#x2F;&#x2F; 创建 Vue 实例，得到 ViewModel var vm &#x3D; new Vue(&#123; el: &#39;#app&#39;, data: &#123;&#125;, methods: &#123;&#125;, router &#125;);watch属性的使用考虑一个问题：想要实现 名 和 姓 两个文本框的内容改变，则全名的文本框中的值也跟着改变；（用以前的知识如何实现？？？）监听data中属性的改变：1234567891011121314151617181920212223242526&lt;div id&#x3D;&quot;app&quot;&gt; &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;firstName&quot;&gt; + &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;lastName&quot;&gt; &#x3D; &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;&#x2F;span&gt; &lt;&#x2F;div&gt; &lt;script&gt; &#x2F;&#x2F; 创建 Vue 实例，得到 ViewModel var vm &#x3D; new Vue(&#123; el: &#39;#app&#39;, data: &#123; firstName: &#39;jack&#39;, lastName: &#39;chen&#39;, fullName: &#39;jack - chen&#39; &#125;, methods: &#123;&#125;, watch: &#123; &#39;firstName&#39;: function (newVal, oldVal) &#123; &#x2F;&#x2F; 第一个参数是新数据，第二个参数是旧数据 this.fullName &#x3D; newVal + &#39; - &#39; + this.lastName; &#125;, &#39;lastName&#39;: function (newVal, oldVal) &#123; this.fullName &#x3D; this.firstName + &#39; - &#39; + newVal; &#125; &#125; &#125;); &lt;&#x2F;script&gt;监听路由对象的改变：12345678910111213141516171819202122232425262728293031323334353637383940&lt;div id&#x3D;&quot;app&quot;&gt; &lt;router-link to&#x3D;&quot;&#x2F;login&quot;&gt;登录&lt;&#x2F;router-link&gt; &lt;router-link to&#x3D;&quot;&#x2F;register&quot;&gt;注册&lt;&#x2F;router-link&gt; &lt;router-view&gt;&lt;&#x2F;router-view&gt; &lt;&#x2F;div&gt; &lt;script&gt; var login &#x3D; Vue.extend(&#123; template: &#39;&lt;h1&gt;登录组件&lt;&#x2F;h1&gt;&#39; &#125;); var register &#x3D; Vue.extend(&#123; template: &#39;&lt;h1&gt;注册组件&lt;&#x2F;h1&gt;&#39; &#125;); var router &#x3D; new VueRouter(&#123; routes: [ &#123; path: &quot;&#x2F;login&quot;, component: login &#125;, &#123; path: &quot;&#x2F;register&quot;, component: register &#125; ] &#125;); &#x2F;&#x2F; 创建 Vue 实例，得到 ViewModel var vm &#x3D; new Vue(&#123; el: &#39;#app&#39;, data: &#123;&#125;, methods: &#123;&#125;, router: router, watch: &#123; &#39;$route.path&#39;: function (newVal, oldVal) &#123; if (newVal &#x3D;&#x3D;&#x3D; &#39;&#x2F;login&#39;) &#123; console.log(&#39;这是登录组件&#39;); &#125; else if (newVal &#x3D;&#x3D;&#x3D; &#39;&#x2F;register&#39;) &#123; console.log(&#39;欢迎进入注册页面&#39;) &#125; &#125; &#125; &#125;); &lt;&#x2F;script&gt;computed计算属性的使用默认只有getter的计算属性：1234567891011121314151617181920212223242526272829303132&lt;div id&#x3D;&quot;app&quot;&gt; &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;firstName&quot;&gt; + &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;lastName&quot;&gt; &#x3D; &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;&#x2F;span&gt; &lt;&#x2F;div&gt; &lt;script&gt; &#x2F;&#x2F; 创建 Vue 实例，得到 ViewModel var vm &#x3D; new Vue(&#123; el: &#39;#app&#39;, data: &#123; firstName: &#39;jack&#39;, lastName: &#39;chen&#39; &#125;, methods: &#123;&#125;, computed: &#123; &#x2F;&#x2F; 在 computed 中，可以定义一些 属性，这些属性，叫做 【计算属性】， 计算属性的，本质，就是 一个方法，只不过，我们在使用 这些计算属性的时候，是把 它们的 名称，直接当作 属性来使用的；并不会把 计算属性，当作方法去调用； &#x2F;&#x2F; 注意1： 计算属性，在引用的时候，一定不要加 () 去调用，直接把它 当作 普通 属性去使用就好了； &#x2F;&#x2F; 注意2： 只要 计算属性，这个 function 内部，所用到的 任何 data 中的数据发送了变化，就会 立即重新计算 这个 计算属性的值 从而更新 fullName 的值 &#x2F;&#x2F; 注意3： 计算属性的求值结果，会被缓存起来，方便下次直接使用； 如果 计算属性方法中，所以来的任何数据，都没有发生过变化，则，不会重新对 计算属性求值； &#x2F;&#x2F;注意4： computed的属性不能在data属性再定义否则会报错 写法一 定义的属性可以引号不加也行 &#39;fullname&#39;或fullname fullname: function () &#123; return this.firstName + &#39; - &#39; + this.lastName; &#125; 写法二 fullName() &#123; return this.firstName + &#39; - &#39; + this.lastName; &#125; &#125; &#125;); &lt;&#x2F;script&gt;定义有getter和setter的计算属性：123456789101112131415161718192021222324252627282930313233343536&lt;div id&#x3D;&quot;app&quot;&gt; &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;firstName&quot;&gt; &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;lastName&quot;&gt; &lt;!-- 点击按钮重新为 计算属性 fullName 赋值 --&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;修改fullName&quot; @click&#x3D;&quot;changeName&quot;&gt; &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;&#x2F;span&gt; &lt;&#x2F;div&gt; &lt;script&gt; &#x2F;&#x2F; 创建 Vue 实例，得到 ViewModel var vm &#x3D; new Vue(&#123; el: &#39;#app&#39;, data: &#123; firstName: &#39;jack&#39;, lastName: &#39;chen&#39; &#125;, methods: &#123; changeName() &#123; this.fullName &#x3D; &#39;TOM - chen2&#39;; &#125; &#125;, computed: &#123; fullName: &#123; &#x2F;&#x2F;不写get 和 set方法默认调用get方法，当有method改变fullName时调用set方法改变对应的data数据 get: function () &#123; return this.firstName + &#39; - &#39; + this.lastName; &#125;, set: function (newVal) &#123; var parts &#x3D; newVal.split(&#39; - &#39;); this.firstName &#x3D; parts[0]; this.lastName &#x3D; parts[1]; &#125; &#125; &#125; &#125;); &lt;&#x2F;script&gt;watch、computed和methods之间的对比computed属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。主要当作属性来使用；computed不会立马取值,用到的时候才会取值. 并且有缓存,依赖数据不改变不更新结果 ，对于任何复杂逻辑，不用表达式而都应当使用计算属性methods方法表示一个具体的操作，主要书写业务逻辑；watch一个对象，键是需要观察的表达式，值是对应回调函数。主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作；可以看作是computed和methods的结合体；watch 立即执行,会先算出来一个旧值.数据变化就执行函数 当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。学习Vue官网的补充1、所以的组件都是vue实力，能够继承vue大部分的属性方法2、不要在选项 property 或回调上使用箭头函数，比如1created: () &#x3D;&gt; console.log(this.a) 或&#96;vm.$watch(&#39;a&#39;, newValue &#x3D;&gt; this.myMethod())&#96;。因为箭头函数并没有 this，this 会作为变量一直向上级词法作用域查找，直至找到为止，经常导致 Uncaugt TypeError: Cannot read property of undefined&#96; 或 &#96;Uncaught TypeError: this.myMethod is not a function 之类的错误。使用 JavaScript 表达式迄今为止，在我们的模板中，我们一直都只绑定简单的 property 键值。但实际上，对于所有的数据绑定，Vue.js 都提供了完全的 JavaScript 表达式支持。1234567&#123;&#123; number + 1 &#125;&#125;&#123;&#123; ok ? &#39;YES&#39; : &#39;NO&#39; &#125;&#125;&#123;&#123; message.split(&#39;&#39;).reverse().join(&#39;&#39;) &#125;&#125;&lt;div v-bind:id&#x3D;&quot;&#39;list-&#39; + id&quot;&gt;&lt;&#x2F;div&gt;这些表达式会在所属 Vue 实例的数据作用域下作为 JavaScript 被解析。有个限制就是，每个绑定都只能包含单个表达式，所以下面的例子都不会生效。12345&lt;!-- 这是语句，不是表达式 --&gt;&#123;&#123; var a &#x3D; 1 &#125;&#125;&lt;!-- 流控制也不会生效，请使用三元表达式 --&gt;&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125;模板表达式都被放在沙盒中，只能访问全局变量的一个白名单，如 Math 和 Date 。你不应该在模板表达式中试图访问用户定义的全局变量。参数可以用方括号括起来的 JavaScript 表达式作为一个指令的参数：1234&lt;!--注意，参数表达式的写法存在一些约束，如之后的“对动态参数表达式的约束”章节所述。--&gt;&lt;a v-bind:[attributeName]&#x3D;&quot;url&quot;&gt; ... &lt;&#x2F;a&gt;这里的 attributeName 会被作为一个 JavaScript 表达式进行动态求值，求得的值将会作为最终的参数来使用。例如，如果你的 Vue 实例有一个 data property attributeName，其值为 &quot;href&quot;，那么这个绑定将等价于 v-bind:href。同样地，你可以使用动态参数为一个动态的事件名绑定处理函数：1&lt;a v-on:[eventName]&#x3D;&quot;doSomething&quot;&gt; ... &lt;&#x2F;a&gt;在这个示例中，当 eventName 的值为 &quot;focus&quot; 时，v-on:[eventName] 将等价于 v-on:focus。对动态参数的值的约束动态参数预期会求出一个字符串，异常情况下值为 null。这个特殊的 null 值可以被显性地用于移除绑定。任何其它非字符串类型的值都将会触发一个警告。对动态参数表达式的约束动态参数表达式有一些语法约束，因为某些字符，如空格和引号，放在 HTML attribute 名里是无效的。例如：12&lt;!-- 这会触发一个编译警告 --&gt;&lt;a v-bind:[&#39;foo&#39; + bar]&#x3D;&quot;value&quot;&gt; ... &lt;&#x2F;a&gt;变通的办法是使用没有空格或引号的表达式，或用计算属性替代这种复杂表达式。在 DOM 中使用模板时 (直接在一个 HTML 文件里撰写模板)，还需要避免使用大写字符来命名键名，因为浏览器会把 attribute 名全部强制转为小写：12345&lt;!--在 DOM 中使用模板时这段代码会被转换为 &#96;v-bind:[someattr]&#96;。除非在实例中有一个名为“someattr”的 property，否则代码不会工作。--&gt;&lt;a v-bind:[someAttr]&#x3D;&quot;value&quot;&gt; ... &lt;&#x2F;a&gt;缩写12345678&lt;!-- 完整语法 --&gt;&lt;a v-bind:href&#x3D;&quot;url&quot;&gt;...&lt;&#x2F;a&gt;&lt;!-- 缩写 --&gt;&lt;a :href&#x3D;&quot;url&quot;&gt;...&lt;&#x2F;a&gt;&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;&lt;a :[key]&#x3D;&quot;url&quot;&gt; ... &lt;&#x2F;a&gt;12345678&lt;!-- 完整语法 --&gt;&lt;a v-on:click&#x3D;&quot;doSomething&quot;&gt;...&lt;&#x2F;a&gt;&lt;!-- 缩写 --&gt;&lt;a @click&#x3D;&quot;doSomething&quot;&gt;...&lt;&#x2F;a&gt;&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;&lt;a @[event]&#x3D;&quot;doSomething&quot;&gt; ... &lt;&#x2F;a&gt;出现name属性12&lt;slot name&#x3D;&#39;Header&#39;&gt;&lt;&#x2F;slot&gt; &lt;transition name&#x3D;&quot;fade&quot;&gt; &lt;&#x2F;transition&gt;","categories":[{"name":"vue","slug":"vue","permalink":"http://180231.xyz/categories/vue/"},{"name":"笔记","slug":"vue/笔记","permalink":"http://180231.xyz/categories/vue/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://180231.xyz/tags/vue/"},{"name":"笔记","slug":"笔记","permalink":"http://180231.xyz/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"我使用的vscode配置eslint + pritter规则编写vue项目","slug":"我使用的vscode配置eslint + pritter规则编写vue项目","date":"2020-12-26T12:09:29.575Z","updated":"2020-12-26T12:24:36.025Z","comments":true,"path":"2020/12/26/我使用的vscode配置eslint + pritter规则编写vue项目/","link":"","permalink":"http://180231.xyz/2020/12/26/%E6%88%91%E4%BD%BF%E7%94%A8%E7%9A%84vscode%E9%85%8D%E7%BD%AEeslint%20+%20pritter%E8%A7%84%E5%88%99%E7%BC%96%E5%86%99vue%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"用户settings.json文件如下配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120&#123; \"editor.fontSize\": 18, \"workbench.iconTheme\": \"vscode-icons\", \"workbench.colorTheme\": \"Panda Syntax\", \"editor.fontFamily\": \"'JetBrains Mono', 'Courier New', monospace\", \"editor.minimap.enabled\": false, \"terminal.integrated.shell.windows\": \"C:\\\\Windows\\\\System32\\\\WindowsPowerShell\\\\v1.0\\\\powershell.exe\", \"workbench.startupEditor\": \"newUntitledFile\", \"git.autofetch\": true, \"editor.semanticTokenColorCustomizations\": null, \"editor.tokenColorCustomizations\": null, \"editor.tabSize\": 2, // By default, common template. Do not modify it!!!!! \"editor.formatOnType\": true, \"window.zoomLevel\": 0, \"editor.detectIndentation\": false, \"files.associations\": &#123; \"*.string\": \"html\", \"*.vue\": \"vue\", \"*.wxss\": \"css\", \"*.wxml\": \"wxml\", \"*.wxs\": \"javascript\", \"*.cjson\": \"jsonc\", \"*.js\": \"javascript\" &#125;, // 为指定的语法定义配置文件或使用带有特定规则的配置文件。 \"emmet.syntaxProfiles\": &#123; \"vue-html\": \"html\", \"vue\": \"html\" &#125;, \"search.exclude\": &#123; \"**/node_modules\": true, \"**/bower_components\": true &#125;, //保存时eslint自动修复错误 \"editor.formatOnSave\": true, // Enable per-language //配置 ESLint 检查的文件类型 \"editor.quickSuggestions\": &#123; \"strings\": true &#125;, // 添加 vue 支持 // 这里是针对vue文件的格式化设置，vue的规则在这里生效 \"vetur.format.options.tabSize\": 2, \"vetur.format.options.useTabs\": false, \"vetur.format.defaultFormatter.html\": \"prettier\", \"vetur.format.defaultFormatter.css\": \"prettier\", \"vetur.format.defaultFormatter.scss\": \"prettier\", \"vetur.format.defaultFormatter.postcss\": \"prettier\", \"vetur.format.defaultFormatter.less\": \"prettier\", \"vetur.format.defaultFormatter.js\": \"prettier\", \"vetur.format.defaultFormatter.sass\": \"sass-formatter\", \"vetur.format.defaultFormatter.ts\": \"prettier\", \"vetur.format.defaultFormatterOptions\": &#123; \"js-beautify-html\": &#123; \"wrap_attributes\": \"aligned-multiple\", // 超过150折行 \"wrap-line-length\": 150 &#125;, // #vue组件中html代码格式化样式 \"prettier\": &#123; \"printWidth\": 120, \"tabWidth\": 2, \"singleQuote\": false, \"trailingComma\": \"none\", \"semi\": false, \"wrap_line_length\": 120, \"wrap_attributes\": \"aligned-multiple\", // 超过150折行 \"proseWrap\": \"always\", \"arrowParens\": \"avoid\", \"bracketSpacing\": true, \"jsxBracketSameLine\": true, \"useTabs\": false, \"overrides\": [ &#123; \"files\": \".prettierrc\", \"options\": &#123; \"parser\": \"json\" &#125; &#125; ] &#125; &#125;, // Enable per-language \"[json]\": &#123; \"editor.defaultFormatter\": \"esbenp.prettier-vscode\" &#125;, \"vetur.validation.template\": false, \"html.format.enable\": false, \"json.format.enable\": false, \"javascript.format.enable\": false, \"typescript.format.enable\": false, \"javascript.format.insertSpaceAfterFunctionKeywordForAnonymousFunctions\": false, \"[html]\": &#123; \"editor.defaultFormatter\": \"esbenp.prettier-vscode\" &#125;, \"[javascript]\": &#123; \"editor.defaultFormatter\": \"esbenp.prettier-vscode\" &#125;, \"[jsonc]\": &#123; \"editor.defaultFormatter\": \"esbenp.prettier-vscode\" &#125;, \"[vue]\": &#123; \"editor.defaultFormatter\": \"octref.vetur\" &#125;, \"emmet.includeLanguages\": &#123; \"wxml\": \"html\" &#125;, \"[typescriptreact]\": &#123; \"editor.defaultFormatter\": \"esbenp.prettier-vscode\" &#125;, // 开启eslint自动修复js/ts功能 \"editor.codeActionsOnSave\": &#123; \"source.fixAll.eslint\": true &#125;, \"javascript.implicitProjectConfig.experimentalDecorators\": true, \"editor.maxTokenizationLineLength\": 200000, \"terminal.integrated.cursorStyle\": \"line\"&#125;vue项目根目录下创建的.prettierrc文件如下配置12345678910111213141516171819202122&#123; &quot;printWidth&quot;: 120, &quot;tabWidth&quot;: 2, &quot;singleQuote&quot;: true, &quot;trailingComma&quot;: &quot;none&quot;, &quot;semi&quot;: false, &quot;wrap_line_length&quot;: 120, &quot;wrap_attributes&quot;: &quot;auto&quot;, &quot;proseWrap&quot;: &quot;always&quot;, &quot;arrowParens&quot;: &quot;avoid&quot;, &quot;bracketSpacing&quot;: false, &quot;jsxBracketSameLine&quot;: true, &quot;useTabs&quot;: false, &quot;overrides&quot;: [ &#123; &quot;files&quot;: &quot;.prettierrc&quot;, &quot;options&quot;: &#123; &quot;parser&quot;: &quot;json&quot; &#125; &#125; ]&#125;这样配置后就能很好地配合eslint规则与格式化代码并存了，不信你试一下Alt+Shirt+F或Ctrl+S都能很好地格式化代码！","categories":[{"name":"eslint","slug":"eslint","permalink":"http://180231.xyz/categories/eslint/"},{"name":"vue","slug":"eslint/vue","permalink":"http://180231.xyz/categories/eslint/vue/"},{"name":"vscode","slug":"eslint/vue/vscode","permalink":"http://180231.xyz/categories/eslint/vue/vscode/"},{"name":"pritter","slug":"eslint/vue/vscode/pritter","permalink":"http://180231.xyz/categories/eslint/vue/vscode/pritter/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://180231.xyz/tags/vue/"},{"name":"eslint","slug":"eslint","permalink":"http://180231.xyz/tags/eslint/"},{"name":"格式化代码","slug":"格式化代码","permalink":"http://180231.xyz/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%BB%A3%E7%A0%81/"}]},{"title":"css知识的查漏补缺","slug":"css知识的查漏补缺","date":"2020-10-29T08:23:23.977Z","updated":"2020-12-22T14:23:45.277Z","comments":true,"path":"2020/10/29/css知识的查漏补缺/","link":"","permalink":"http://180231.xyz/2020/10/29/css%E7%9F%A5%E8%AF%86%E7%9A%84%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/","excerpt":"","text":"技能学习12345&lt;div style&#x3D;&quot;width:400px; height:200px;&quot;&gt; &lt;span style&#x3D;&quot;float:left; width:auto; height:100%;&quot;&gt; &lt;i style&#x3D;&quot;position:absolute;float:left; width:100px; height:50px;&quot;&gt;hello&lt;&#x2F;i&gt; &lt;&#x2F;span&gt;&lt;&#x2F;div&gt;问题：span 标签的width 和height 分别为多少？（ ）A . width =0px，height = 0pxB . width =400px，height = 200pxC . width =100px，height = 50pxD . width =0px，height = 200px解释：span是行内元素设置宽高无效，但是float:left促发BFC，对行内元素促发BFC相当云把行内元素变成行内块元素，所以width的auto也就不能自动继承父元素了，于是width=0，而高度为100%则是父元素的高度，所以选D（不懂的自己敲一下就懂了）1.1 浏览器的分类国外：ie，chrome，火狐，欧朋，苹果Safari(ios,imac)已经退出历史舞台的浏览器：网景公司国内：QQ,360,baidu,uc,猎豹,遨游,搜狗 – 不入流的浏览器1.2 浏览器内核浏览器内核就是用来渲染网页效果的1、IE浏览器内核：Trident内核，也是俗称的IE内核；2、Chrome浏览器内核：统称为Chromium内核或Chrome内核，以前是Webkit内核，现在是Blink内核；3、Firefox浏览器内核：Gecko内核，俗称Firefox内核；4、Safari浏览器内核：Webkit内核；5、Opera浏览器内核：最初是自己的Presto内核，后来是Webkit，现在是Blink内核；6、360浏览器、猎豹浏览器内核：IE+Chrome双内核；7、搜狗、遨游、QQ浏览器内核：Trident（兼容模式）+Webkit（高速模式）；8、百度浏览器、世界之窗内核：IE内核；2345浏览器内核：以前是IE内核，现在也是IE+Chrome双内核；1.3走马灯标签(已经过时，请不要再使用)1&lt;marquee behavior&#x3D;&quot;alternate&quot; direction&#x3D;&quot;right&quot;&gt;来回滚动的文字&lt;&#x2F;marquee&gt;主要属性：​ behavior：alternate(来回滚动)|scroll(单方向循环滚动)|slide(只滚动一次)​ bgcolor:文字滚动范围的背景颜色​ direction:文字滚动的方向 down|left|right|up​ width、height:范围大小​ hspace和vspace:这两个属性决定滚动矩形区域距周围的空白区域.​ loop:滚动次数，缺省是无限循环。-1或infinite将无限循环。​ scrollamount和scrolldelay:文字滚动的速度(scrollamount)和延时(scrolldelay)，参数值都是正整数。​ onmouseover=this.stop() onmouseout=this.start() 表示当鼠标以上区域的时候滚动停止，当鼠标移开的时候又继续滚动。1.4 Doctype1&lt;!DOCTYPE html&gt;Doctype的作用：告诉浏览器，以哪一个标准去解析页面删除doctype，则没有告诉浏览器的解析方案，浏览器会按照(quirks mode怪异模式)各个浏览器自己的方案去解析1.5 表单1 表单表单是用在网页上唯一能操作的地方，也是用户唯一与数据库产生关联的地方。表单的作用：向后台数据库提交数据或查询数据。标签属性值formaction表示表单提交的后台地址method表单提交的方式：get|post ，get：以地址栏方式提交，post：以保密方式提交enctypeapplication/x-www-form-urlencoded：普通表单的提交 multipart/form-data：有文件上传时的表单提交inputtype设置表单的类型： text单行文本框 password：密码框 radio：单选按钮 checkbox：复选按钮 file：文件选择框 submit：提交按钮 reset：重置按钮 button：普通按钮 image：图片按钮 hidden：隐藏域value设置表单的缺省值，提交到后台的数据name表单必填的属性，提交给后台的数据maxlength表单输入的最大长度size表单的宽度readonly表单只读，表单能被提交disabled禁用表单，表单不能被提交selectname下拉列表optionvalue下拉列表选项，配合select使用textareacols,rows多行文本域，设置宽高字体如何实现在同一段文本实现中英文使用不同的字体？1font-family: Cambria, 华文彩云;原来就是Cambria没有中文字体然后向后找，于是找到华文彩云这个字体注意：设置字体时候备用字体使用常用的放到后面，因为字体查找是在本机字体库如window的font文件夹下的字体css选择器权重问题!important内联样式（1000）ID 选择器（0100）类选择器 / 属性选择器 / 伪类选择器（0010）元素选择器 / 关系选择器 / 伪元素选择器（0001）通配选择器（0000）123456&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;test.css&quot;&gt; &lt;style&gt; .box &#123; color: blue; &#125; &lt;&#x2F;style&gt;这两种方式加载按文档的加载顺序，后面覆盖前面样式的原则慎用!important，因为在调试操作css样式或者js操作文档的元素改变样式的时候会因为权重问题失效1.6 inline-block的坑inline-block不可以完全代替float布局，也不建议。坑1： 元素有字体的间距，需要使用letter-spacing设为合适的负数去掉或者设置父元素的字体大小为0，坑2： 设置为display：inline-block后不能再使用display：none隐藏元素可能会对其他元素布局有影响1.7 链接式与导入式的区别1、标签是属于XHTML范畴的，@import是属于CSS2.1中特有的。2、使用链接的CSS是客户端浏览网页时先将外部CSS文件加载到网页当中，然后再进行编译显示，所以这种情况下显示出来的网页与用户预期的效果一样，即使网速再慢也一样的效果。3、使用@import导入的CSS文件，客户端在浏览网页时是先将HTML结构呈现出来，再把外部CSS文件加载到网页当中，当然最终的效果也与使用链接文件效果一样，只是当网速较慢时会先显示没有CSS统一布局的HTML网页，这样就会给用户很不好的感觉。这个也是现在目前大多少网站采用链接外部样式表的主要原因。4、由于@import是属于CSS2.1中特有的，因此对于不兼容CSS2.1的浏览器来说就是无效的。1.1 继承性作用：子元素可以继承父元素的样式。什么样的属性才可以继承：text-,font-,line-开头的属性都是可以继承的color.特殊的标签：1、a标签的颜色不能继承，如果一定要修改a标签的颜色直接作用在a标签上面。2、h标签的大小不能继承，如果一定要修改h标签的大小直接作用在h标签上面。3、div的高度如果不设置，由内容来决定（没有内容那么高度 为0），宽度默认由父元素继承过来。不具有继承性的属性：边框、外边距、内边距、背景、定位、元素宽高属性。恰当地使用继承可以简化代码，降低CSS样式的复杂性。子元素脱标父元素高度丢失，1、设置父元素高度2、父元素使用overflow：hidden，超出部分隐藏，适合没有超出内容的区域3、加一个div使用clear：both4、使用伪元素能用js实现的不用图片实现，能用css实现的不用js实现","categories":[{"name":"css","slug":"css","permalink":"http://180231.xyz/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"http://180231.xyz/tags/css/"}]},{"title":"vue-cli4搭建的vue项目在GitHub上演示,有手就行","slug":"vue-cli4搭建的vue项目在GitHub上演示","date":"2020-09-07T04:14:23.143Z","updated":"2020-09-07T04:18:05.796Z","comments":true,"path":"2020/09/07/vue-cli4搭建的vue项目在GitHub上演示/","link":"","permalink":"http://180231.xyz/2020/09/07/vue-cli4%E6%90%AD%E5%BB%BA%E7%9A%84vue%E9%A1%B9%E7%9B%AE%E5%9C%A8GitHub%E4%B8%8A%E6%BC%94%E7%A4%BA/","excerpt":"","text":"前言​ 我们开源的vue新项目怎么在线上访问得到呢？购买服务器自己搭建？不需要。好好利用好github这平台就行了。开始第一步这vue项目的根路径创建start.sh然后在start.sh文件中配置以下内容123456789101112# 当发生错误时中止脚本set -e# 构建npm run build# cd 到构建输出的目录下 cd distgit initgit add -Agit commit -m &#39;start&#39;# 部署到 https:&#x2F;&#x2F;&lt;github用户名&gt;.github.io&#x2F;&lt;仓库名&gt;git push -f git@github.com:&lt;github用户名&gt;&#x2F;&lt;仓库名&gt;.git master:gh-pagescd -在vue.config.js文件中配置以下内容1234567module.exports &#x3D; &#123; &#x2F;&#x2F; 生产环境 sourceMap productionSourceMap: false, publicPath: process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;production&#39; ? &#39;&#x2F;仓库名&#x2F;&#39; : &#39;&#x2F;&#39;&#125;第二步在当前项目根目录下右击打开git bash Here(一定要git打开不然执行不了.sh文件，我的是win10)然后切换到主分支(默认)执行 sh start.sh （eslint报错自己修改）然后github打开该项目的setting ，拉到下面GitHub Pages, 如我的点击网址就能访问了，这就大功告成了！网址是因为我的绑定了域名不然的应该为：https://xxxx.gihub.io/xxxx这个格式下面放上我的完整配置图","categories":[{"name":"vue","slug":"vue","permalink":"http://180231.xyz/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://180231.xyz/tags/vue/"},{"name":"vue-cli4","slug":"vue-cli4","permalink":"http://180231.xyz/tags/vue-cli4/"},{"name":"github项目演示","slug":"github项目演示","permalink":"http://180231.xyz/tags/github%E9%A1%B9%E7%9B%AE%E6%BC%94%E7%A4%BA/"}]},{"title":"原创vue+vuex仿telegram app的单页应用，实现分组功能消息发送","slug":"tg总结","date":"2020-09-07T04:14:23.139Z","updated":"2020-09-07T04:16:35.047Z","comments":true,"path":"2020/09/07/tg总结/","link":"","permalink":"http://180231.xyz/2020/09/07/tg%E6%80%BB%E7%BB%93/","excerpt":"","text":"*前言*vue2仿telegram这个项目我把自己所学的vue大部分知识都用上了，可以说覆盖了vue和vuex的大部分知识，通过这项目对vue有了更加深刻的理解以及更灵活的应用。源码地址：https://github.com/xxydrr/vue-telegram效果演示点击查看demo（PC浏览器预览时请切换到手机预览模式同时建议刷新一下再预览）移动端扫描下方二维码二维码查看技术栈脚手架工具 vue-cli@4.4.6主体：vue + vue-router + vuex + scss +mint ui+mui+es6其他：better-scroll + animate.css实现功能页面展示动画交互信息发送分组功能删除联系人搜索联系人用户部分信息修改badge组件响应式更新消息免打扰持续完善…总结1、telegram最新版有小小改动更新了部分setting编辑个人信息样式时间有限我就不改过来了。2、目前已经显示文字聊天功能，后期应该会加入表情功能，特别是gif。3、为什么加入了过于多余的mui，加入mui纯属是为了练习学会使用这种类型的ui库，因为这和bootstrap使用方式类似。4、个人这项目可以作为这是很好使用vuex的一个例子，因为vuex的绝大部分常用知识都用到了。5、该项目基本使用插件第三方库的来实现，对插件第三方库的使用有更深刻使用心得。6、该项目后期有时间将会加入axios+mock或者axios+node.js后台完善该项目。敬请期待！！！部分屏幕截图联系人界面)对话界面)对话面板界面)查看以及编辑好友信息)个人设置)","categories":[{"name":"vue","slug":"vue","permalink":"http://180231.xyz/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://180231.xyz/tags/vue/"},{"name":"vuex","slug":"vuex","permalink":"http://180231.xyz/tags/vuex/"},{"name":"telegram","slug":"telegram","permalink":"http://180231.xyz/tags/telegram/"}]},{"title":"消息尾部添加时间","slug":"消息尾部添加时间","date":"2020-09-07T04:14:23.137Z","updated":"2020-09-07T04:18:42.489Z","comments":true,"path":"2020/09/07/消息尾部添加时间/","link":"","permalink":"http://180231.xyz/2020/09/07/%E6%B6%88%E6%81%AF%E5%B0%BE%E9%83%A8%E6%B7%BB%E5%8A%A0%E6%97%B6%E9%97%B4/","excerpt":"","text":"前言​ 我们如何在发送消息的尾部添加事件呢？如以下这种效果可能我们首先想到消息的div加定位position: relative 右侧加个padding-right;然后在time的span加position: absolute;如果一行是完全ok的，但是多行的情况下就不行的非常丑陋。我们正确的做法应该是在消息的文本后面加个span，*&lt;span class=”hide”&gt;0:00&lt;/span&gt;*，然后.hide的visibility: hidden;就行了，因为visibility是实际占位的，而display是不占空间的。具体代码如下12345678910111213141516171819202122232425262728293031323334&lt;li v-for&#x3D;&quot;(item,index) in selectedChat.messages&quot; :key&#x3D;&quot;index&quot; class&#x3D;&quot;chat-detail chat-detail-left&quot; &gt; &lt;div class&#x3D;&quot;chat-user&quot;&gt;&lt;img :src&#x3D;&quot;selectedChat.user.img&quot;&gt;&lt;&#x2F;div&gt; &lt;p class&#x3D;&quot;chat-text clearfix&quot;&gt;&#123;&#123;item.content&#125;&#125; &lt;span class&#x3D;&quot;hide&quot;&gt;0:00&lt;&#x2F;span&gt;&lt;span class&#x3D;&quot;time&quot;&gt;&#123;&#123;item.date | formatTime&#125;&#125;&lt;&#x2F;span&gt;&lt;&#x2F;p&gt;&lt;&#x2F;li&gt; .chat-text &#123; display: inline-block; max-width: 250px; position: relative; bottom: 0; margin-top: 10px; margin-bottom: 6px; color: #000; background: #f1f1f4; font-size: 16px; line-height: 25px; text-align: left; word-break: break-all; .hide &#123; visibility: hidden; &#125; .time &#123; position: absolute; display: inline-block; font-size: 10px; color: #aaaaab; bottom: 2px; &#125;","categories":[{"name":"vue","slug":"vue","permalink":"http://180231.xyz/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://180231.xyz/tags/vue/"},{"name":"vue编码规范","slug":"vue编码规范","permalink":"http://180231.xyz/tags/vue%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"},{"name":"css编码规范","slug":"css编码规范","permalink":"http://180231.xyz/tags/css%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"}]},{"title":"我的vue项目编码规范","slug":"vue项目值得注意的书写规范","date":"2020-08-24T09:19:52.719Z","updated":"2020-08-24T10:37:49.021Z","comments":false,"path":"2020/08/24/vue项目值得注意的书写规范/","link":"","permalink":"http://180231.xyz/2020/08/24/vue%E9%A1%B9%E7%9B%AE%E5%80%BC%E5%BE%97%E6%B3%A8%E6%84%8F%E7%9A%84%E4%B9%A6%E5%86%99%E8%A7%84%E8%8C%83/","excerpt":"","text":"1、组件/实例的选项顺序（同步官方）。官方链接这是我们推荐的组件选项默认顺序。它们被划分为几大类，所以你也能知道从插件里添加的新 property 应该放到哪里。副作用 (触发组件外的影响)el全局感知 (要求组件以外的知识)nameparent组件类型 (更改组件的类型)functional模板修改器 (改变模板的编译方式)delimiterscomments模板依赖 (模板内使用的资源)componentsdirectivesfilters组合 (向选项里合并 property)extendsmixins接口 (组件的接口)inheritAttrsmodelprops/propsData本地状态 (本地的响应式 property)datacomputed事件 (通过响应式事件触发的回调)watch生命周期钩子 (按照它们被调用的顺序)beforeCreatecreatedbeforeMountmountedbeforeUpdateupdatedactivateddeactivatedbeforeDestroydestroyed非响应式的 property (不依赖响应系统的实例 property)methods渲染 (组件输出的声明式描述)template/renderrenderError因此实际开发过程中用得比较多的选项顺序如下1234567891011121314151617181920212223242526export default &#123; name: &#39;demo&#39;, components: &#123;&#125;, directives: &#123;&#125;, filters: &#123;&#125;, extends: Object, mixins: [], props: &#123;&#125;, data() &#123; return &#123; &#125; &#125;, computed: &#123;&#125;, watch: &#123;&#125;, beforeCreate() &#123;&#125;, created() &#123;&#125;, beforeMount() &#123;&#125;, mounted() &#123;&#125;, beforeUpdate() &#123;&#125;, updated() &#123;&#125;, activated() &#123;&#125;, deactivated() &#123;&#125;, beforeDestroy() &#123;&#125;, destroyed() &#123;&#125;, methods() &#123;&#125;&#125;2、元素 (包括组件) 的 attribute 应该有统一的顺序（同步官方）。官方这是我们为组件选项推荐的默认顺序。它们被划分为几大类，所以你也能知道新添加的自定义 attribute 和指令应该放到哪里。定义 (提供组件的选项)is列表渲染 (创建多个变化的相同元素)v-for条件渲染 (元素是否渲染/显示)v-ifv-else-ifv-elsev-showv-cloak渲染方式 (改变元素的渲染方式)v-prev-once全局感知 (需要超越组件的知识)id唯一的 attribute (需要唯一值的 attribute)refkey双向绑定 (把绑定和事件结合起来)v-model其它 attribute (所有普通的绑定或未绑定的 attribute)事件 (组件事件监听器)v-on内容 (覆写元素的内容)v-htmlv-text因此实际开发过程中用得比较多的元素特征顺序如下1234567891011121314151617181920212223- v-for- v-if&#x2F;v-show- id- ref&#x2F;key&#x2F;slot- v-model- class&#x2F;:class&#x2F;style&#x2F;:style- v-on&lt;div(组件同理) v-for&#x3D;&quot;(item, index) in items&quot; :key&#x3D;&quot;index&quot; v-if&#x3D;&quot;condition&quot; id&#x3D;&quot;&quot; ref&#x3D;&quot;&quot; key&#x3D;&quot;&quot; slot&#x3D;&quot;&quot; v-model&#x3D;&quot;something&quot; class&#x3D;&quot;&quot; :class&#x3D;&quot;&quot; style&#x3D;&quot;&quot; :style&#x3D;&quot;&quot; v-on:event&#x3D;&quot;handle&quot;&gt;&lt;&#x2F;div&gt;3、css样式书写规范（参照官网以及某大公司的规范）1、首先我们为CSS类命名时应使用lowercase-hyphenated2、[建议] border / margin/ padding等缩写会同时设置多个属性的值，容易覆盖不需要覆盖的设定。如某些方向需要继承其他声明的值，则应该分开设置。3、属性书写顺序[建议] 同一 rule set 下的属性在书写时，应按功能进行分组，并以 Formatting Model（布局方式、位置） &gt; Box Model（尺寸） &gt; Typographic（文本相关） &gt; Visual（视觉效果） 的顺序书写，以提高代码的可读性。解释：Formatting Model 相关属性包括：position / top / right / bottom / left / float / display / overflow 等Box Model 相关属性包括：border / margin / padding / width / height 等Typographic 相关属性包括：font / line-height / text-align / word-wrap 等Visual 相关属性包括：background / color / transition / list-style 等另外，如果包含 content 属性，应放在最前面。示例：1234567891011121314151617181920212223.sidebar &#123; &#x2F;* formatting model: positioning schemes &#x2F; offsets &#x2F; z-indexes &#x2F; display &#x2F; ... *&#x2F; position: absolute; top: 50px; left: 0; overflow-x: hidden; &#x2F;* box model: sizes &#x2F; margins &#x2F; paddings &#x2F; borders &#x2F; ... *&#x2F; width: 200px; padding: 5px; border: 1px solid #ddd; &#x2F;* typographic: font &#x2F; aligns &#x2F; text styles &#x2F; ... *&#x2F; font-size: 14px; line-height: 20px; &#x2F;* visual: colors &#x2F; shadows &#x2F; gradients &#x2F; ... *&#x2F; background: #f5f5f5; color: #333; -webkit-transition: color 1s; -moz-transition: color 1s; transition: color 1s;&#125;4 、清除浮动[建议] 当元素需要撑起高度以包含内部的浮动元素时，通过对伪类设置 clear 或触发 BFC 的方式进行 clearfix。尽量不使用增加空标签的方式。5、 !important[建议] 尽量不使用 !important 声明。[建议] 当需要强制指定样式且不允许任何场景覆盖时，通过标签内联和 !important 定义样式。6、数值[强制] 当数值为 0 - 1 之间的小数时，省略整数部分的 0。7、长度[强制] 长度为 0 时须省略单位。 (也只有长度单位可省)8 、颜色[强制] RGB颜色值必须使用十六进制记号形式 #rrggbb。不允许使用 rgb()。[强制] 颜色值可以缩写时，必须使用缩写形式。[强制] 颜色值不允许使用命名色值。[建议] 颜色值中的英文字符采用小写。如不用小写也需要保证同一项目内保持大小写一致。示例：1234567891011121314151617&#x2F;* good *&#x2F;.success &#123; background-color: #aca; color: #90ee90;&#125;&#x2F;* good *&#x2F;.success &#123; background-color: #ACA; color: #90EE90;&#125;&#x2F;* bad *&#x2F;.success &#123; background-color: #ACA; color: #90ee90;&#125;9、字体[强制] 需要在 Windows 平台显示的中文内容，其字号应不小于 12px。解释：由于 Windows 的字体渲染机制，小于 12px 的文字显示效果极差、难以辨认。[强制] font-weight 属性必须使用数值方式描述。解释：CSS 的字重分 100 – 900 共九档，但目前受字体本身质量和浏览器的限制，实际上支持 400 和 700 两档，分别等价于关键词 normal 和 bold。浏览器本身使用一系列启发式规则来进行匹配，在 &lt;700 时一般匹配字体的 Regular 字重，&gt;=700 时匹配 Bold 字重。但已有浏览器开始支持 =600 时匹配 Semibold 字重 (见此表)，故使用数值描述增加了灵活性，也更简短。123456789&#x2F;* good *&#x2F;h1 &#123; font-weight: 700;&#125;&#x2F;* bad *&#x2F;h1 &#123; font-weight: bold;&#125;[建议] line-height 在定义文本段落时，应使用数值。解释：将 line-height 设置为数值，浏览器会基于当前元素设置的 font-size 进行再次计算。在不同字号的文本段落组合中，能达到较为舒适的行间间隔效果，避免在每个设置了 font-size 都需要设置 line-height。当 line-height 用于控制垂直居中时，还是应该设置成与容器高度一致。10、变换与动画[强制] 使用 transition 时应指定 transition-property。示例：123456789&#x2F;* good *&#x2F;.box &#123; transition: color 1s, border-color 1s;&#125;&#x2F;* bad *&#x2F;.box &#123; transition: all 1s;&#125;至于其他的缩进规则以及js书写规范及美化我们交给交给格式化文档工具vetur插件以及eslint解决就行了","categories":[{"name":"vue","slug":"vue","permalink":"http://180231.xyz/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://180231.xyz/tags/vue/"},{"name":"vue编码规范","slug":"vue编码规范","permalink":"http://180231.xyz/tags/vue%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"},{"name":"css编码规范","slug":"css编码规范","permalink":"http://180231.xyz/tags/css%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"}]},{"title":"js类与继承和对象关联设计模式解读","slug":"js类与继承和对象关联风格解读","date":"2020-06-30T10:24:00.000Z","updated":"2020-12-22T14:24:10.883Z","comments":true,"path":"2020/06/30/js类与继承和对象关联风格解读/","link":"","permalink":"http://180231.xyz/2020/06/30/js%E7%B1%BB%E4%B8%8E%E7%BB%A7%E6%89%BF%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%85%B3%E8%81%94%E9%A3%8E%E6%A0%BC%E8%A7%A3%E8%AF%BB/","excerpt":"","text":"前言读完了《你不知道的js上卷》后，使用了类与继承与，对象关联风格与行为委托实现一个简单的个人任务管理系统。通过实战后对这两种设计模式有了更加深刻的了解。代码部分对比类与继承设计模式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&#x2F;&#x2F;bulletBox.js(function(_) &#123; var template &#x3D; &#96;&lt;div class&#x3D;&quot;overlay&quot;&gt; &lt;div class&#x3D;&quot;box&quot;&gt; &lt;div class&#x3D;&quot;box-title&quot;&gt; &lt;h3&gt;消息提醒&lt;&#x2F;h3&gt; &lt;div class&#x3D;&quot;box-close icon-cross1&quot;&gt;&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;box-main&quot;&gt; &lt;div class&#x3D;&quot;new-title&quot;&gt; &lt;h3 class&#x3D;&quot;nameValue&quot;&gt;名称：&lt;&#x2F;h3&gt; &lt;input type&#x3D;&quot;text&quot;&gt; &lt;&#x2F;div&gt; &lt;button class&#x3D;&quot;btn2 confirm&quot;&gt;确定&lt;&#x2F;button&gt; &lt;button class&#x3D;&quot;btn2 cancel&quot;&gt;取消&lt;&#x2F;button&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt;&#96;; function Modal(options) &#123; this.options &#x3D; options || &#123;&#125;; this.container &#x3D; this.layout.cloneNode(true); this.body &#x3D; this.container.querySelector(&#39;.new-title&#39;); this.bodyContent &#x3D; this.container.querySelector(&#39;.new-title h3&#39;); this.input &#x3D; this.body.querySelector(&#39;input&#39;); &#x2F;&#x2F; 将options复制到组件实例上 _.mixin(this,options); this._renderUI(); this._initEvent(); return this; &#125; &#x2F;&#x2F;这里使用显示混入的方式，也可以使用原型对象关联的方式 Modal.prototype &#x3D; Object.create(&#123;&#125;) _.mixin(Modal.prototype, &#123; layout: _.htmlTranslate(template), &#x2F;&#x2F; 添加节点 appendTo: function(node) &#123; node.appendChild(this.container); &#125;, &#x2F;&#x2F; 显示弹窗 show: function(content) &#123; this.container.style.display &#x3D; &#39;block&#39;; &#125;, &#x2F;&#x2F; 隐藏弹窗 hide: function() &#123; this.container.style.display &#x3D; &#39;none&#39;; &#125;, &#x2F;&#x2F; 销毁弹窗 destroy: function() &#123; this.container.parentNode.removeChild(this.container); &#125;, _renderUI: function() &#123; if(this.hasFlag &#x3D;&#x3D;&#x3D; true) &#123; &#x2F;&#x2F; this.body.removeChild(&#39;hasInput&#39;) this.input.parentNode.removeChild(this.input); this.text &amp;&amp; (this.bodyContent.innerText &#x3D; this.text); &#125; &#125;, _initEvent: function() &#123; _.addEvent(this.container.querySelector(&#39;.confirm&#39;), &#39;click&#39;, this.onConfirm.bind(this)); _.addEvent(this.container.querySelector(&#39;.cancel&#39;), &#39;click&#39;, this.onCancel.bind(this)); &#125;, onConfirm: function() &#123; this.emit(&#39;confirm&#39;); this.destroy(); &#125;, onCancel: function() &#123; this.emit(&#39;cancel&#39;); this.destroy(); &#125; &#125;) &#x2F;&#x2F; 使用混入Mixin的方式使得Modal具有事件发射器功能 _.mixin(Modal.prototype, _.emitter); &#x2F;&#x2F; 暴露到全局 window.Modal &#x3D; Modal;&#125;)(util)&#x2F;&#x2F;main.js new Modal() .on(&#39;confirm&#39;, function() &#123; if(this.input.value.trim() !&#x3D; &#39;&#39;) &#123; var index &#x3D; &#39;&#39;; if(selectCG.className.indexOf(&#39;sub-category&#39;) !&#x3D; -1) &#123; index &#x3D; &#39;&#39; + (data.category.push(&#123;name: this.input.value, number: 0, todos: [], subCategory: []&#125;) - 1); &#125; else &#123; index &#x3D; selectCG.index + &#39;-&#39; + (data.category[selectCG.index].subCategory.push(&#123;name: this.input.value, number: 0, todos:[]&#125;) - 1); &#125; &#125; &#x2F;&#x2F; 更新分类列表 updateCGList(data.category, index); _.save(data); &#125;) .appendTo(document.body);主要在构造函数function Modal(options) 声明属性赋值以及初始化工作，通过混入在Modal.prototype定义方法，然后调用new Modal时侯一次实现构造和初始化工作。然后通过链式调用需要的方法。对象关联风格与行为委托设计模式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576(function(_) &#123; var template &#x3D; &#96;&lt;div class&#x3D;&quot;overlay&quot;&gt; &lt;div class&#x3D;&quot;box&quot;&gt; &lt;div class&#x3D;&quot;box-title&quot;&gt; &lt;h3&gt;消息提醒&lt;&#x2F;h3&gt; &lt;div class&#x3D;&quot;box-close icon-cross1&quot;&gt;&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;box-main&quot;&gt; &lt;div class&#x3D;&quot;new-title&quot;&gt; &lt;h3 class&#x3D;&quot;nameValue&quot;&gt;名称：&lt;&#x2F;h3&gt; &lt;input type&#x3D;&quot;text&quot;&gt; &lt;&#x2F;div&gt; &lt;button class&#x3D;&quot;btn2 confirm&quot;&gt;确定&lt;&#x2F;button&gt; &lt;button class&#x3D;&quot;btn2 cancel&quot;&gt;取消&lt;&#x2F;button&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt;&#96;; var Modal &#x3D; &#123; init: function(options) &#123; this.options &#x3D; options || &#123;&#125;; this.container &#x3D; this.layout.cloneNode(true); this.body &#x3D; this.container.querySelector(&#39;.new-title&#39;); this.bodyContent &#x3D; this.container.querySelector(&#39;.new-title h3&#39;); this.input &#x3D; this.body.querySelector(&#39;input&#39;); 修改原型链使Modal对象的原型链上有_.emitter的方法 Object.setPrototypeOf(Modal,_.emitter); this._renderUI(); this._initEvent(); &#125;, layout: _.htmlTranslate(template), &#x2F;&#x2F; 添加节点 appendTo: function(node) &#123; node.appendChild(this.container); &#125;, &#x2F;&#x2F; 显示弹窗 show(content) &#123; this.container.style.display &#x3D; &#39;block&#39;; &#125;, &#x2F;&#x2F; 隐藏弹窗 hide() &#123; this.container.style.display &#x3D; &#39;none&#39;; &#125;, &#x2F;&#x2F; 销毁弹窗 destroy() &#123; this.container.parentNode.removeChild(this.container); &#125;, _renderUI: function() &#123; if(this.options.hasFlag &#x3D;&#x3D;&#x3D; true) &#123; &#x2F;&#x2F; this.body.removeChild(&#39;hasInput&#39;) this.input.parentNode.removeChild(this.input); this.options.text &amp;&amp; (this.bodyContent.innerText &#x3D; this.options.text); &#125; &#125;, _initEvent: function() &#123; _.addEvent(this.container.querySelector(&#39;.confirm&#39;), &#39;click&#39;, this.onConfirm.bind(this)); _.addEvent(this.container.querySelector(&#39;.cancel&#39;), &#39;click&#39;, this.onCancel.bind(this)); &#125;, onConfirm() &#123; this.emit(&#39;confirm&#39;); this.destroy(); &#125;, onCancel() &#123; this.emit(&#39;cancel&#39;); this.destroy(); &#125; &#125; &#x2F;&#x2F; 暴露到全局 window.Modal &#x3D; Modal;&#125;)(util)对象关联这种风格只需要在组件上定义一个对象，不在需要prototype定义方法属性了。也不需要显示混入的复制方式，而是使用es6的新方法 Object.setPrototypeOf()修改[[prototype]]链达到同样的目的。但是在调用的时候实现构造实例化初始化的时候需要分两步（关联对象和初始化），而且它不能通过类与继承的方式.().().()这样直接链式调用方法，不过这样对初学者来说可以增加代码的可读性，也更好实现关注分离原则。如果还是不理解他们之间的区别，可以看看我的这个项目再回头看你不知道的js上的第二部分的后面几章节你就会深有体会了个人看法之前第一次看你不知的js的时候作者对对象关联与行为委托的设计模式不断的赞赏，而不断对js的类与继承的模式进行吐槽。这可能作者觉得js应该使用自己的独有的语言风格而不是极力地模仿类的方式。个人觉得js有意让这两种模式都能平衡地发展，因为es6为了两种模式都添加了新的语法，如class， Object.setPrototypeOf()方法等。所以，我觉得两种模式看个人选择，没有好坏之分，重点是实现功能完成项目。","categories":[{"name":"js设计模式","slug":"js设计模式","permalink":"http://180231.xyz/categories/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://180231.xyz/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"设计模式","slug":"设计模式","permalink":"http://180231.xyz/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"类与继承","slug":"类与继承","permalink":"http://180231.xyz/tags/%E7%B1%BB%E4%B8%8E%E7%BB%A7%E6%89%BF/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-06-15T01:44:54.519Z","updated":"2020-06-15T02:18:51.708Z","comments":true,"path":"2020/06/15/hello-world/","link":"","permalink":"http://180231.xyz/2020/06/15/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.Quick StartCreate a new post1$ hexo new \"My New Post\"More info: WritingRun server1$ hexo serverMore info: ServerGenerate static files1$ hexo generateMore info: GeneratingDeploy to remote sites1$ hexo deployMore info: Deployment","categories":[],"tags":[]},{"title":"2020年最新Github+Hexo+Cloudflare+域名搭建博客详解教程","slug":"2020年最新Github+Hexo+域名博客搭建详解教程","date":"2020-06-14T10:24:00.000Z","updated":"2020-07-01T01:35:48.833Z","comments":true,"path":"2020/06/14/2020年最新Github+Hexo+域名博客搭建详解教程/","link":"","permalink":"http://180231.xyz/2020/06/14/2020%E5%B9%B4%E6%9C%80%E6%96%B0Github+Hexo+%E5%9F%9F%E5%90%8D%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AF%A6%E8%A7%A3%E6%95%99%E7%A8%8B/","excerpt":"","text":"前言​ 本博客构建于2020年6月13日，看了网上的好几个教程发现都是要不关键步骤不够详细要不软件更新迭代过快自己的部分步骤与博主不相符下面让我详细介绍我的搭建之路。熟悉nmp操作的会很快上手，直接跳过node的安装安装步骤安装node通过 NVM 安装Node.js（注意需安装Node.js 10.0 及以上版本）NVM：node.js version manager，用来管理 node 的版本。安装的步骤如下。（1）我们去官网下载 NVM 的安装包：下载下来后，直接解压到 F:\\dev目录下：（2）在上面的目录中，点击install.cmd自动生成settings.txt文件，里面的内容填充如下：1234root: F:\\dev\\nvmpath: F:\\dev\\nodejsarch: 64proxy上方内容的解释：root 配置为：当前 nvm.exe 所在的目录path 配置为：node 快捷方式所在的目录arch 配置为：当前操作系统的位数（32/64）proxy 不用配置（3）配置环境变量：NVM_HOME = D:\\web\\nvm（当前 nvm.exe 所在目录）NVM_SYMLINK = D:\\web\\nodejs （node 快捷方式所在的目录）PATH += ;%NVM_HOME%;%NVM_SYMLINK%配置成功后，重启资源管理器。验证：(在 cmd 中输入命令)（1）输入nvm命令查看环境变量是否配置成功：由于nvm默认的下载地址http://nodejs.org/dist/是外国外服务器，国内很慢可以使用淘宝的镜像。找到刚刚解压的nvm文件夹下的settings.txt文件在其后加入这两句话，并保存12node_mirror: https:&#x2F;&#x2F;npm.taobao.org&#x2F;mirrors&#x2F;node&#x2F;npm_mirror: https:&#x2F;&#x2F;npm.taobao.org&#x2F;mirrors&#x2F;npm&#x2F;（2）然后可以开始下载对应的node版本，推荐下载一个稳定版本和一个最新的版本下载最新版本直接执行指令nvm install latest就行了，稳定版本自己去官网找然后按nvm install 后面加版本号，例如nvm install 12.18.0 就能下载对应的node版本（3）输入 nvm ls，查看已安装的所有 node 版本。（4）输入 nvm -v，查看 已安装的 nvm 版本。（5）输入 node -v，查看正在使用的 node 版本。（6）输入nvm use 版本号即可切换对应的版本。 如输入命令nvm use 12.18.0后按nvm ls后node的版本前带有*号即代表当前使用的node版本（7）由于npm的下载地址为https://registry.npmjs.org/是国外服务器，国内很慢可以使用淘宝的镜像执行下面的命令即可123456&#x2F;&#x2F; 配置地址npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org&#x2F;&#x2F; 安装npm install&#x2F;&#x2F;设置为原来的地址npm config set registry https:&#x2F;&#x2F;registry.npmjs.org&#x2F;参考链接：安装npm，nvm，node如果 node 安装失败，可以参考上面这个链接再不行自己上网找。注册GitHubgithub点击GitHub中的New repository创建新仓库。仓库名为：你的用户名**.http://github.io 这是固定写法为了后面操作更简单，如我的因为我已经有了这个名字的仓库所以才有这个警告，直接创建仓库安装git（期间Git Bash Here窗口会弹窗要求你输入GitHub的账号密码输入即可）git真的是傻瓜式安装直接下一步下一步到了添加路径三选一选择的时候选择第二个Use Git from the Windows Command Prompt就行了直接自动帮你配置环境这些操作。在命令行输入git查看是否安装成功或者右击鼠标有以下显示点击Git Bash Here一一输入以下指令（git的终端的复制快捷键是ctrl+ins，粘贴的快捷键是shift+ins，停止终端命令都和别的终端命令一样是ctrl+c）1234git config --global user.name &quot;你的GitHub用户名&quot;git config --global user.email &quot;你的GitHub注册邮箱&quot;&#x2F;&#x2F;生成ssh密钥文件：ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot;然后会在你的C盘的用户下的.ssh会有这个文件，如可能那个known_hosts文件没有生成，不过不用管他，之后在Git Bash中执行某条指令是提示你缺少这个文件是否安装继续你就按yes就行，他自动帮你安装补全然后用word或者记事本之类的软件打开上面的红色框文件，然后ctrl+A全部复制，回到你的GitHub，点击右上角的GitHub后按setting，然后按左边栏的SSH and GPG keys，然后点击绿色按钮New SSH key，出现以下文本框这里的第一行title随便你填，把刚才的id_rsa.pub文本内容复制到key文本框，直接按绿色的按钮Add SSH key在Git Bash中输入1ssh -T git@github.com提示这个直接按yes之后提示你xx用户，你已经成功认证安装 Hexo这时我们在电脑里创建一个文件夹，可以命名为Blog，Hexo框架与以后你自己发布的网页都在这个文件夹中，然后在当前blog文件夹打开cmd，即进入blog文件夹可以按ctrl+L在任务栏输入cmd或者直接打开cmd后把blog文件夹拖拽到cmd窗口所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。（使用npm安装插件有时会出现黄色的WARN直接无视它不是ERRO就没事,下同）1npm install -g hexo-cli进阶安装和使用（推荐）对于熟悉 npm 的进阶用户，可以仅局部安装 hexo 包。12&#x2F;&#x2F;推荐局部安装npm install hexo安装完成后继续输入1hexo init blog然后一一输入以下指令12345hexo new firstBolg&#x2F;&#x2F;生成静态网页hexo g&#x2F;&#x2F;打开本地服务器hexo s然后浏览器打开http://localhost:4000/，这是我们就可以看到自己初步形成的静态网站博客了，时不时有了大功告成的感觉了Hexo与GitHub关联这一步我们实现将自己的网页部署到网上，网址是GitHub提供给我们的xxxx.github.io访问打开站点的配置文件_config.yml（即blog文件夹下的_config.yml），翻到最后修改为：1234deploy: type: git repository: 你的仓库地址(如我的是https:&#x2F;&#x2F;github.com&#x2F;xxydrr&#x2F;xxydrr.github.io) branch: master注意：deploy前面不要留空格，下面的三行话前面有两个空格。.yml的文件格式非常严格然后在blog文件夹下打开cmd（blog文件夹下按ctrl+L在地址栏输入cmd按Enter即可），安装一个插件1npm install hexo-deployer-git --save然后输入hexo new post &quot;article title&quot;，新建一篇文章。然后打开blog\\source\\_posts的目录，可以发现下面多了一个.md文件，就是你的文章文件。编写完markdown文件后，blog目录下右键打开git bash依次输入以下三条命令123hexo clean hexo g hexo d完成后，打开浏览器，在地址栏输入你的放置个人网站的仓库路径，即xxxx.github.io,你就会发现你的博客已经上线了，可以在网络上被访问了。绑定域名我们要自己的个性化域名，这就需要绑定我们自己的域名。这里演示腾讯云的域名绑定，在国内主流的域名代理厂商也就阿里云和腾讯云。还没有购买域名的小伙伴可能要等几天才能进行域名绑定操作，因为域名注册后还要实名给注册局注册才能用。不过你可以先跳到配置hexo和主题选择部分继续操作登录到腾讯云，进入管理控制台的域名列表，找到你的个性化域名，点击解析进入解释，参考我的简单介绍以下记录值192.30.252.153和192.30.252.154是GitHub的服务器地址，最后的主机类型www记录类型A记录值是你的github域名打开你的github博客项目，点击settings，拉到下面Custom domain处，填上你自己的域名，保存：然后进入blog/source目录下，创建一个记事本文件，输入你的域名。保存，命名为CNAME ，注意保存成所有文件即文件没有后缀然后在blog目录下右键打开git bash123hexo cleanhexo ghexo d这时候打开浏览器输入你的域名将会直接进入你自己搭建的网站。配置主题如果你不喜欢Hexo默认的主题，可以更换不同的主题，主题传送门：Themes 我自己使用的是pure。配置主题是非常复杂的事情，各个主题的源码不同配置方式也不同。因为首先你想要找到你自己喜欢的主题，然后点进去他的github下载源码到自己博客的themes文件夹下。因为每个人的审美不同，我自己的主题也是自己一步步配置的，找到自己喜欢的主题进去他的主题源码有个markdown文件教你怎么配置的了。在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。所以我总结的配置主题方法就是找到自己喜欢的主题然后打开他的说明markdown文档以及上作者主题的GitHub查看Issue看看别人出现问题怎么解决自己有没出现，也可以去hexo官方文档查看博客主题配置，这样才能配置出自己喜欢的主题，下面我总结以下通用主题的配置方式(1)添加背景动画在\\themes\\{你的主题名}\\layout\\layout.ejs的*&lt;/*body&gt;后中面添加(2)添加404页面在\\blog\\themes\\{你的主题名}\\source 下新建404.html文件，404文件的样式源码可以自己上网搜我的是404源码然后引入对应的css文件和images文件就行了(4)后台管理插件hexo-adminGithub：https://github.com/jaredly/hexo-admin简介：可以直接在网页端创建、编辑markdown文章内容，并将内容发布到_posts里。最方便的是可以很方便的给文章加标题、分类、打标签。配置按照它的官网操作进行了套Cloudflare简单说Cloudflare免费提供cdn服务即可以使你的网站访问加速，并且自定义域名提供免费的 https 服务而不会通过域名访问时显示网站不安全的提示。使用方式进入Cloudflare官网，然后填入个人域名选择免费套餐接着这一步如果你已经在域名服务商那里解析过域名的话，就会出现你域名的解析列表（下图是我的另一个域名没有解释）点击下一步 Cloudflare 会有非常详细的提示，回到域名管理删除默认的域名服务器替代为CloundFlare名称服务器几个小时后就能颁发证书成功，你可以登录Cloudflare看一下也可以打开自己的博客网站然后打开开发者工具按Network，点击左边的name对应的域名查看右边的Heders的server已经是cloudflare代表已经成功了第一篇博客编写博客编写建议使用现在主流的markdown形式，markdown软件建议使用Typora编写或者用你的编辑器写也行1hexo new &quot;hello blog&quot;输入这条命令后将会在blog\\source_posts文件夹下看到helloblog.md文T件，打开他的源代码形式是12345---title: hello blog //题目date: 2020-06-14 19:46:42 //时间tags: //标签---这是基本的文章配置，注意一定要按照这样的格式在开头编写文章的配置，更多的配置请参考自己对应的主题markdown说明文档补充。然后就可以编写文章了，下面是简单的markdown语法及其快捷键12345678910111213Typora快捷键整合Ctrl+1 一阶标题 Ctrl+B 字体加粗Ctrl+2 二阶标题 Ctrl+I 字体倾斜Ctrl+3 三阶标题 Ctrl+U 下划线Ctrl+4 四阶标题 Ctrl+Home 返回Typora顶部Ctrl+5 五阶标题 Ctrl+End 返回Typora底部Ctrl+6 六阶标题 Ctrl+T 创建表格Ctrl+L 选中某句话 Ctrl+K 创建超链接Ctrl+D 选中某个单词 Ctrl+F 搜索Ctrl+E 选中相同格式的文字 Ctrl+H 搜索并替换Alt+Shift+5 删除线 Ctrl+Shift+I 插入图片Ctrl+Shift+M 公式块 Ctrl+Shift+Q 引用注：一些实体符号需要在实体符号之前加”\\”才能够显示图床准备这里我推荐使用微博图床，下面看我的超级简单方法（1）安装这个浏览器插件新浪微博图床然后简直白嫖一样，点击插件然后在浏览器上登录自己的微博就能用了，图片不会存在自己微博的相册中也不会自动发微博啥的，然后点击这个插件还可以查看自己的历史图片然后拉进去就可以快乐插图片继续写文章了发布文章准备建议首先依次输入这三条指令本地查看一下先123456789hexo clean &#x2F;&#x2F;清除缓存文件 db.json 和已生成的静态文件 public网站显示异常时可以执行这条命令试试。hexo g &#x2F;&#x2F;生成网站静态文件到默认设置的 public 文件夹。 &#x2F;&#x2F;便于查看网站生成的静态文件或者手动部署网站；如果使用自动部署， &#x2F;&#x2F;不需要先执行该命令hexo g 是 hexo generate 的缩写，命令效果一致。hexo s &#x2F;&#x2F;启动本地服务器，用于预览主题。默认地址： http:&#x2F;&#x2F;localhost:4000&#x2F;hexo s 是 hexo server 的缩写， &#x2F;&#x2F;命令效果一致；预览的同时可以修改文章内容或主题代码，保存后刷新页面即可；对 Hexo 根目录 _config.yml 的修改， &#x2F;&#x2F;需要重启本地服务器后才能预览效果。感觉没问题后执行hexo d把它部署到自己的GitHub仓库中，接着我们就能在网上输入自己的域名查看效果了1hexo d &#x2F;&#x2F;自动生成网站静态文件，并部署到设定的仓库。hexo d 是 hexo deploy 的缩写，命令效果一致。之后我们常用的hexo组合指令是12hexo clean &amp;&amp; hexo shexo clean &amp;&amp; hexo d然后就大功告成了，谢谢阅读！","categories":[{"name":"hexo博客搭建","slug":"hexo博客搭建","permalink":"http://180231.xyz/categories/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://180231.xyz/tags/hexo/"},{"name":"GitHub","slug":"GitHub","permalink":"http://180231.xyz/tags/GitHub/"},{"name":"博客","slug":"博客","permalink":"http://180231.xyz/tags/%E5%8D%9A%E5%AE%A2/"}]}],"categories":[{"name":"vue","slug":"vue","permalink":"http://180231.xyz/categories/vue/"},{"name":"笔记","slug":"vue/笔记","permalink":"http://180231.xyz/categories/vue/%E7%AC%94%E8%AE%B0/"},{"name":"eslint","slug":"eslint","permalink":"http://180231.xyz/categories/eslint/"},{"name":"vue","slug":"eslint/vue","permalink":"http://180231.xyz/categories/eslint/vue/"},{"name":"vscode","slug":"eslint/vue/vscode","permalink":"http://180231.xyz/categories/eslint/vue/vscode/"},{"name":"pritter","slug":"eslint/vue/vscode/pritter","permalink":"http://180231.xyz/categories/eslint/vue/vscode/pritter/"},{"name":"css","slug":"css","permalink":"http://180231.xyz/categories/css/"},{"name":"js设计模式","slug":"js设计模式","permalink":"http://180231.xyz/categories/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"hexo博客搭建","slug":"hexo博客搭建","permalink":"http://180231.xyz/categories/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://180231.xyz/tags/vue/"},{"name":"笔记","slug":"笔记","permalink":"http://180231.xyz/tags/%E7%AC%94%E8%AE%B0/"},{"name":"eslint","slug":"eslint","permalink":"http://180231.xyz/tags/eslint/"},{"name":"格式化代码","slug":"格式化代码","permalink":"http://180231.xyz/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%BB%A3%E7%A0%81/"},{"name":"css","slug":"css","permalink":"http://180231.xyz/tags/css/"},{"name":"vue-cli4","slug":"vue-cli4","permalink":"http://180231.xyz/tags/vue-cli4/"},{"name":"github项目演示","slug":"github项目演示","permalink":"http://180231.xyz/tags/github%E9%A1%B9%E7%9B%AE%E6%BC%94%E7%A4%BA/"},{"name":"vuex","slug":"vuex","permalink":"http://180231.xyz/tags/vuex/"},{"name":"telegram","slug":"telegram","permalink":"http://180231.xyz/tags/telegram/"},{"name":"vue编码规范","slug":"vue编码规范","permalink":"http://180231.xyz/tags/vue%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"},{"name":"css编码规范","slug":"css编码规范","permalink":"http://180231.xyz/tags/css%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"},{"name":"面向对象","slug":"面向对象","permalink":"http://180231.xyz/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"设计模式","slug":"设计模式","permalink":"http://180231.xyz/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"类与继承","slug":"类与继承","permalink":"http://180231.xyz/tags/%E7%B1%BB%E4%B8%8E%E7%BB%A7%E6%89%BF/"},{"name":"hexo","slug":"hexo","permalink":"http://180231.xyz/tags/hexo/"},{"name":"GitHub","slug":"GitHub","permalink":"http://180231.xyz/tags/GitHub/"},{"name":"博客","slug":"博客","permalink":"http://180231.xyz/tags/%E5%8D%9A%E5%AE%A2/"}]}