{"meta":{"title":"搞搞震iBB","subtitle":"前端博客，爱设计，知识分享，瞎折腾新事物的切图仔","description":"前端，设计，博客，软件，网页","author":"搞搞震iBB","url":"http://180231.xyz","root":"/"},"pages":[{"title":"书单","date":"2020-06-15T02:55:28.268Z","updated":"2020-06-12T12:57:41.873Z","comments":false,"path":"books/index.html","permalink":"http://180231.xyz/books/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-06-14T07:50:05.506Z","updated":"2020-06-14T07:45:34.817Z","comments":false,"path":"about/index.html","permalink":"http://180231.xyz/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"分类","date":"2020-06-14T07:45:35.104Z","updated":"2020-06-14T07:45:35.104Z","comments":false,"path":"categories/index.html","permalink":"http://180231.xyz/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-06-14T09:35:27.000Z","updated":"2020-06-14T09:35:29.326Z","comments":false,"path":"repository/index.html","permalink":"http://180231.xyz/repository/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-06-14T09:34:59.000Z","updated":"2020-06-14T09:34:59.694Z","comments":true,"path":"links/index.html","permalink":"http://180231.xyz/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-06-14T07:50:35.467Z","updated":"2020-06-14T07:45:34.816Z","comments":false,"path":"tags/index.html","permalink":"http://180231.xyz/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"vue项目值得注意的书写规范","slug":"vue项目值得注意的书写规范","date":"2020-08-24T09:19:52.719Z","updated":"2020-08-24T10:05:48.143Z","comments":false,"path":"2020/08/24/vue项目值得注意的书写规范/","link":"","permalink":"http://180231.xyz/2020/08/24/vue%E9%A1%B9%E7%9B%AE%E5%80%BC%E5%BE%97%E6%B3%A8%E6%84%8F%E7%9A%84%E4%B9%A6%E5%86%99%E8%A7%84%E8%8C%83/","excerpt":"","text":"1、组件/实例的选项顺序（同步官方）。官方链接这是我们推荐的组件选项默认顺序。它们被划分为几大类，所以你也能知道从插件里添加的新 property 应该放到哪里。副作用 (触发组件外的影响)el全局感知 (要求组件以外的知识)nameparent组件类型 (更改组件的类型)functional模板修改器 (改变模板的编译方式)delimiterscomments模板依赖 (模板内使用的资源)componentsdirectivesfilters组合 (向选项里合并 property)extendsmixins接口 (组件的接口)inheritAttrsmodelprops/propsData本地状态 (本地的响应式 property)datacomputed事件 (通过响应式事件触发的回调)watch生命周期钩子 (按照它们被调用的顺序)beforeCreatecreatedbeforeMountmountedbeforeUpdateupdatedactivateddeactivatedbeforeDestroydestroyed非响应式的 property (不依赖响应系统的实例 property)methods渲染 (组件输出的声明式描述)template/renderrenderError因此实际开发过程中用得比较多的选项顺序如下1234567891011121314151617181920212223242526export default &#123; name: &#39;demo&#39;, components: &#123;&#125;, directives: &#123;&#125;, filters: &#123;&#125;, extends: Object, mixins: [], props: &#123;&#125;, data() &#123; return &#123; &#125; &#125;, computed: &#123;&#125;, watch: &#123;&#125;, beforeCreate() &#123;&#125;, created() &#123;&#125;, beforeMount() &#123;&#125;, mounted() &#123;&#125;, beforeUpdate() &#123;&#125;, updated() &#123;&#125;, activated() &#123;&#125;, deactivated() &#123;&#125;, beforeDestroy() &#123;&#125;, destroyed() &#123;&#125;, methods() &#123;&#125;&#125;2、元素 (包括组件) 的 attribute 应该有统一的顺序（同步官方）。官方这是我们为组件选项推荐的默认顺序。它们被划分为几大类，所以你也能知道新添加的自定义 attribute 和指令应该放到哪里。定义 (提供组件的选项)is列表渲染 (创建多个变化的相同元素)v-for条件渲染 (元素是否渲染/显示)v-ifv-else-ifv-elsev-showv-cloak渲染方式 (改变元素的渲染方式)v-prev-once全局感知 (需要超越组件的知识)id唯一的 attribute (需要唯一值的 attribute)refkey双向绑定 (把绑定和事件结合起来)v-model其它 attribute (所有普通的绑定或未绑定的 attribute)事件 (组件事件监听器)v-on内容 (覆写元素的内容)v-htmlv-text因此实际开发过程中用得比较多的元素特征顺序如下1234567891011121314151617181920212223- v-for- v-if&#x2F;v-show- id- ref&#x2F;key&#x2F;slot- v-model- class&#x2F;:class&#x2F;style&#x2F;:style- v-on&lt;div(组件同理) v-for&#x3D;&quot;(item, index) in items&quot; :key&#x3D;&quot;index&quot; v-if&#x3D;&quot;condition&quot; id&#x3D;&quot;&quot; ref&#x3D;&quot;&quot; key&#x3D;&quot;&quot; slot&#x3D;&quot;&quot; v-model&#x3D;&quot;something&quot; class&#x3D;&quot;&quot; :class&#x3D;&quot;&quot; style&#x3D;&quot;&quot; :style&#x3D;&quot;&quot; v-on:event&#x3D;&quot;handle&quot;&gt;&lt;&#x2F;div&gt;3、css样式书写规范（参照官网以及某大公司的规范）1、首先我们为CSS类命名时应使用lowercase-hyphenated2、[建议] border / margin/ padding等缩写会同时设置多个属性的值，容易覆盖不需要覆盖的设定。如某些方向需要继承其他声明的值，则应该分开设置。3、属性书写顺序[建议] 同一 rule set 下的属性在书写时，应按功能进行分组，并以 Formatting Model（布局方式、位置） &gt; Box Model（尺寸） &gt; Typographic（文本相关） &gt; Visual（视觉效果） 的顺序书写，以提高代码的可读性。解释：Formatting Model 相关属性包括：position / top / right / bottom / left / float / display / overflow 等Box Model 相关属性包括：border / margin / padding / width / height 等Typographic 相关属性包括：font / line-height / text-align / word-wrap 等Visual 相关属性包括：background / color / transition / list-style 等另外，如果包含 content 属性，应放在最前面。示例：1234567891011121314151617181920212223.sidebar &#123; &#x2F;* formatting model: positioning schemes &#x2F; offsets &#x2F; z-indexes &#x2F; display &#x2F; ... *&#x2F; position: absolute; top: 50px; left: 0; overflow-x: hidden; &#x2F;* box model: sizes &#x2F; margins &#x2F; paddings &#x2F; borders &#x2F; ... *&#x2F; width: 200px; padding: 5px; border: 1px solid #ddd; &#x2F;* typographic: font &#x2F; aligns &#x2F; text styles &#x2F; ... *&#x2F; font-size: 14px; line-height: 20px; &#x2F;* visual: colors &#x2F; shadows &#x2F; gradients &#x2F; ... *&#x2F; background: #f5f5f5; color: #333; -webkit-transition: color 1s; -moz-transition: color 1s; transition: color 1s;&#125;4 、清除浮动[建议] 当元素需要撑起高度以包含内部的浮动元素时，通过对伪类设置 clear 或触发 BFC 的方式进行 clearfix。尽量不使用增加空标签的方式。5、 !important[建议] 尽量不使用 !important 声明。[建议] 当需要强制指定样式且不允许任何场景覆盖时，通过标签内联和 !important 定义样式。6、数值[强制] 当数值为 0 - 1 之间的小数时，省略整数部分的 0。7、长度[强制] 长度为 0 时须省略单位。 (也只有长度单位可省)8 、颜色[强制] RGB颜色值必须使用十六进制记号形式 #rrggbb。不允许使用 rgb()。[强制] 颜色值可以缩写时，必须使用缩写形式。[强制] 颜色值不允许使用命名色值。[建议] 颜色值中的英文字符采用小写。如不用小写也需要保证同一项目内保持大小写一致。示例：1234567891011121314151617&#x2F;* good *&#x2F;.success &#123; background-color: #aca; color: #90ee90;&#125;&#x2F;* good *&#x2F;.success &#123; background-color: #ACA; color: #90EE90;&#125;&#x2F;* bad *&#x2F;.success &#123; background-color: #ACA; color: #90ee90;&#125;9、字体[强制] 需要在 Windows 平台显示的中文内容，其字号应不小于 12px。解释：由于 Windows 的字体渲染机制，小于 12px 的文字显示效果极差、难以辨认。[强制] font-weight 属性必须使用数值方式描述。解释：CSS 的字重分 100 – 900 共九档，但目前受字体本身质量和浏览器的限制，实际上支持 400 和 700 两档，分别等价于关键词 normal 和 bold。浏览器本身使用一系列启发式规则来进行匹配，在 &lt;700 时一般匹配字体的 Regular 字重，&gt;=700 时匹配 Bold 字重。但已有浏览器开始支持 =600 时匹配 Semibold 字重 (见此表)，故使用数值描述增加了灵活性，也更简短。123456789&#x2F;* good *&#x2F;h1 &#123; font-weight: 700;&#125;&#x2F;* bad *&#x2F;h1 &#123; font-weight: bold;&#125;[建议] line-height 在定义文本段落时，应使用数值。解释：将 line-height 设置为数值，浏览器会基于当前元素设置的 font-size 进行再次计算。在不同字号的文本段落组合中，能达到较为舒适的行间间隔效果，避免在每个设置了 font-size 都需要设置 line-height。当 line-height 用于控制垂直居中时，还是应该设置成与容器高度一致。10、变换与动画[强制] 使用 transition 时应指定 transition-property。示例：123456789&#x2F;* good *&#x2F;.box &#123; transition: color 1s, border-color 1s;&#125;&#x2F;* bad *&#x2F;.box &#123; transition: all 1s;&#125;至于其他的缩进规则以及js书写规范及美化我们交给交给格式化文档工具vetur插件以及eslint解决就行了","categories":[{"name":"vue","slug":"vue","permalink":"http://180231.xyz/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://180231.xyz/tags/vue/"},{"name":"vue书写规范","slug":"vue书写规范","permalink":"http://180231.xyz/tags/vue%E4%B9%A6%E5%86%99%E8%A7%84%E8%8C%83/"},{"name":"css书写规范","slug":"css书写规范","permalink":"http://180231.xyz/tags/css%E4%B9%A6%E5%86%99%E8%A7%84%E8%8C%83/"}]},{"title":"js类与继承和对象关联设计模式解读","slug":"js类与继承和对象关联风格解读","date":"2020-06-30T10:24:00.000Z","updated":"2020-07-01T01:30:42.430Z","comments":true,"path":"2020/06/30/js类与继承和对象关联风格解读/","link":"","permalink":"http://180231.xyz/2020/06/30/js%E7%B1%BB%E4%B8%8E%E7%BB%A7%E6%89%BF%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%85%B3%E8%81%94%E9%A3%8E%E6%A0%BC%E8%A7%A3%E8%AF%BB/","excerpt":"","text":"前言读完了《你不知的js上卷》后，使用了类与继承与，对象关联风格与行为委托实现一个简单的个人任务管理系统。通过实战后对这两种设计模式有了更加深刻的了解。代码部分对比类与继承设计模式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&#x2F;&#x2F;bulletBox.js(function(_) &#123; var template &#x3D; &#96;&lt;div class&#x3D;&quot;overlay&quot;&gt; &lt;div class&#x3D;&quot;box&quot;&gt; &lt;div class&#x3D;&quot;box-title&quot;&gt; &lt;h3&gt;消息提醒&lt;&#x2F;h3&gt; &lt;div class&#x3D;&quot;box-close icon-cross1&quot;&gt;&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;box-main&quot;&gt; &lt;div class&#x3D;&quot;new-title&quot;&gt; &lt;h3 class&#x3D;&quot;nameValue&quot;&gt;名称：&lt;&#x2F;h3&gt; &lt;input type&#x3D;&quot;text&quot;&gt; &lt;&#x2F;div&gt; &lt;button class&#x3D;&quot;btn2 confirm&quot;&gt;确定&lt;&#x2F;button&gt; &lt;button class&#x3D;&quot;btn2 cancel&quot;&gt;取消&lt;&#x2F;button&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt;&#96;; function Modal(options) &#123; this.options &#x3D; options || &#123;&#125;; this.container &#x3D; this.layout.cloneNode(true); this.body &#x3D; this.container.querySelector(&#39;.new-title&#39;); this.bodyContent &#x3D; this.container.querySelector(&#39;.new-title h3&#39;); this.input &#x3D; this.body.querySelector(&#39;input&#39;); &#x2F;&#x2F; 将options复制到组件实例上 _.mixin(this,options); this._renderUI(); this._initEvent(); return this; &#125; &#x2F;&#x2F;这里使用显示混入的方式，也可以使用原型对象关联的方式 Modal.prototype &#x3D; Object.create(&#123;&#125;) _.mixin(Modal.prototype, &#123; layout: _.htmlTranslate(template), &#x2F;&#x2F; 添加节点 appendTo: function(node) &#123; node.appendChild(this.container); &#125;, &#x2F;&#x2F; 显示弹窗 show: function(content) &#123; this.container.style.display &#x3D; &#39;block&#39;; &#125;, &#x2F;&#x2F; 隐藏弹窗 hide: function() &#123; this.container.style.display &#x3D; &#39;none&#39;; &#125;, &#x2F;&#x2F; 销毁弹窗 destroy: function() &#123; this.container.parentNode.removeChild(this.container); &#125;, _renderUI: function() &#123; if(this.hasFlag &#x3D;&#x3D;&#x3D; true) &#123; &#x2F;&#x2F; this.body.removeChild(&#39;hasInput&#39;) this.input.parentNode.removeChild(this.input); this.text &amp;&amp; (this.bodyContent.innerText &#x3D; this.text); &#125; &#125;, _initEvent: function() &#123; _.addEvent(this.container.querySelector(&#39;.confirm&#39;), &#39;click&#39;, this.onConfirm.bind(this)); _.addEvent(this.container.querySelector(&#39;.cancel&#39;), &#39;click&#39;, this.onCancel.bind(this)); &#125;, onConfirm: function() &#123; this.emit(&#39;confirm&#39;); this.destroy(); &#125;, onCancel: function() &#123; this.emit(&#39;cancel&#39;); this.destroy(); &#125; &#125;) &#x2F;&#x2F; 使用混入Mixin的方式使得Modal具有事件发射器功能 _.mixin(Modal.prototype, _.emitter); &#x2F;&#x2F; 暴露到全局 window.Modal &#x3D; Modal;&#125;)(util)&#x2F;&#x2F;main.js new Modal() .on(&#39;confirm&#39;, function() &#123; if(this.input.value.trim() !&#x3D; &#39;&#39;) &#123; var index &#x3D; &#39;&#39;; if(selectCG.className.indexOf(&#39;sub-category&#39;) !&#x3D; -1) &#123; index &#x3D; &#39;&#39; + (data.category.push(&#123;name: this.input.value, number: 0, todos: [], subCategory: []&#125;) - 1); &#125; else &#123; index &#x3D; selectCG.index + &#39;-&#39; + (data.category[selectCG.index].subCategory.push(&#123;name: this.input.value, number: 0, todos:[]&#125;) - 1); &#125; &#125; &#x2F;&#x2F; 更新分类列表 updateCGList(data.category, index); _.save(data); &#125;) .appendTo(document.body);主要在构造函数function Modal(options) 声明属性赋值以及初始化工作，通过混入在Modal.prototype定义方法，然后调用new Modal时侯一次实现构造和初始化工作。然后通过链式调用需要的方法。对象关联风格与行为委托设计模式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576(function(_) &#123; var template &#x3D; &#96;&lt;div class&#x3D;&quot;overlay&quot;&gt; &lt;div class&#x3D;&quot;box&quot;&gt; &lt;div class&#x3D;&quot;box-title&quot;&gt; &lt;h3&gt;消息提醒&lt;&#x2F;h3&gt; &lt;div class&#x3D;&quot;box-close icon-cross1&quot;&gt;&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;box-main&quot;&gt; &lt;div class&#x3D;&quot;new-title&quot;&gt; &lt;h3 class&#x3D;&quot;nameValue&quot;&gt;名称：&lt;&#x2F;h3&gt; &lt;input type&#x3D;&quot;text&quot;&gt; &lt;&#x2F;div&gt; &lt;button class&#x3D;&quot;btn2 confirm&quot;&gt;确定&lt;&#x2F;button&gt; &lt;button class&#x3D;&quot;btn2 cancel&quot;&gt;取消&lt;&#x2F;button&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt;&#96;; var Modal &#x3D; &#123; init: function(options) &#123; this.options &#x3D; options || &#123;&#125;; this.container &#x3D; this.layout.cloneNode(true); this.body &#x3D; this.container.querySelector(&#39;.new-title&#39;); this.bodyContent &#x3D; this.container.querySelector(&#39;.new-title h3&#39;); this.input &#x3D; this.body.querySelector(&#39;input&#39;); 修改原型链使Modal对象的原型链上有_.emitter的方法 Object.setPrototypeOf(Modal,_.emitter); this._renderUI(); this._initEvent(); &#125;, layout: _.htmlTranslate(template), &#x2F;&#x2F; 添加节点 appendTo: function(node) &#123; node.appendChild(this.container); &#125;, &#x2F;&#x2F; 显示弹窗 show(content) &#123; this.container.style.display &#x3D; &#39;block&#39;; &#125;, &#x2F;&#x2F; 隐藏弹窗 hide() &#123; this.container.style.display &#x3D; &#39;none&#39;; &#125;, &#x2F;&#x2F; 销毁弹窗 destroy() &#123; this.container.parentNode.removeChild(this.container); &#125;, _renderUI: function() &#123; if(this.options.hasFlag &#x3D;&#x3D;&#x3D; true) &#123; &#x2F;&#x2F; this.body.removeChild(&#39;hasInput&#39;) this.input.parentNode.removeChild(this.input); this.options.text &amp;&amp; (this.bodyContent.innerText &#x3D; this.options.text); &#125; &#125;, _initEvent: function() &#123; _.addEvent(this.container.querySelector(&#39;.confirm&#39;), &#39;click&#39;, this.onConfirm.bind(this)); _.addEvent(this.container.querySelector(&#39;.cancel&#39;), &#39;click&#39;, this.onCancel.bind(this)); &#125;, onConfirm() &#123; this.emit(&#39;confirm&#39;); this.destroy(); &#125;, onCancel() &#123; this.emit(&#39;cancel&#39;); this.destroy(); &#125; &#125; &#x2F;&#x2F; 暴露到全局 window.Modal &#x3D; Modal;&#125;)(util)对象关联这种风格只需要在组件上定义一个对象，不在需要prototype定义方法属性了。也不需要显示混入的复制方式，而是使用es6的新方法 Object.setPrototypeOf()修改[[prototype]]链达到同样的目的。但是在调用的时候实现构造实例化初始化的时候需要分两步（关联对象和初始化），而且它不能通过类与继承的方式.().().()这样直接链式调用方法，不过这样对初学者来说可以增加代码的可读性，也更好实现关注分离原则。如果还是不理解他们之间的区别，可以看看我的这个项目再回头看你不知道的js上的第二部分的后面几章节你就会深有体会了个人看法之前第一次看你不知的js的时候作者对对象关联与行为委托的设计模式不断的赞赏，而不断对js的类与继承的模式进行吐槽。这可能作者觉得js应该使用自己的独有的语言风格而不是极力地模仿类的方式。个人觉得js有意让这两种模式都能平衡地发展，因为es6为了两种模式都添加了新的语法，如class， Object.setPrototypeOf()方法等。所以，我觉得两种模式看个人选择，没有好坏之分，重点是实现功能完成项目。","categories":[{"name":"js设计模式","slug":"js设计模式","permalink":"http://180231.xyz/categories/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://180231.xyz/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"设计模式","slug":"设计模式","permalink":"http://180231.xyz/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"类与继承","slug":"类与继承","permalink":"http://180231.xyz/tags/%E7%B1%BB%E4%B8%8E%E7%BB%A7%E6%89%BF/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-06-15T01:44:54.519Z","updated":"2020-06-15T02:18:51.708Z","comments":true,"path":"2020/06/15/hello-world/","link":"","permalink":"http://180231.xyz/2020/06/15/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.Quick StartCreate a new post1$ hexo new \"My New Post\"More info: WritingRun server1$ hexo serverMore info: ServerGenerate static files1$ hexo generateMore info: GeneratingDeploy to remote sites1$ hexo deployMore info: Deployment","categories":[],"tags":[]},{"title":"2020年最新Github+Hexo+Cloudflare+域名搭建博客详解教程","slug":"2020年最新Github+Hexo+域名博客搭建详解教程","date":"2020-06-14T10:24:00.000Z","updated":"2020-07-01T01:35:48.833Z","comments":true,"path":"2020/06/14/2020年最新Github+Hexo+域名博客搭建详解教程/","link":"","permalink":"http://180231.xyz/2020/06/14/2020%E5%B9%B4%E6%9C%80%E6%96%B0Github+Hexo+%E5%9F%9F%E5%90%8D%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AF%A6%E8%A7%A3%E6%95%99%E7%A8%8B/","excerpt":"","text":"前言​ 本博客构建于2020年6月13日，看了网上的好几个教程发现都是要不关键步骤不够详细要不软件更新迭代过快自己的部分步骤与博主不相符下面让我详细介绍我的搭建之路。熟悉nmp操作的会很快上手，直接跳过node的安装安装步骤安装node通过 NVM 安装Node.js（注意需安装Node.js 10.0 及以上版本）NVM：node.js version manager，用来管理 node 的版本。安装的步骤如下。（1）我们去官网下载 NVM 的安装包：下载下来后，直接解压到 F:\\dev目录下：（2）在上面的目录中，点击install.cmd自动生成settings.txt文件，里面的内容填充如下：1234root: F:\\dev\\nvmpath: F:\\dev\\nodejsarch: 64proxy上方内容的解释：root 配置为：当前 nvm.exe 所在的目录path 配置为：node 快捷方式所在的目录arch 配置为：当前操作系统的位数（32/64）proxy 不用配置（3）配置环境变量：NVM_HOME = D:\\web\\nvm（当前 nvm.exe 所在目录）NVM_SYMLINK = D:\\web\\nodejs （node 快捷方式所在的目录）PATH += ;%NVM_HOME%;%NVM_SYMLINK%配置成功后，重启资源管理器。验证：(在 cmd 中输入命令)（1）输入nvm命令查看环境变量是否配置成功：由于nvm默认的下载地址http://nodejs.org/dist/是外国外服务器，国内很慢可以使用淘宝的镜像。找到刚刚解压的nvm文件夹下的settings.txt文件在其后加入这两句话，并保存12node_mirror: https:&#x2F;&#x2F;npm.taobao.org&#x2F;mirrors&#x2F;node&#x2F;npm_mirror: https:&#x2F;&#x2F;npm.taobao.org&#x2F;mirrors&#x2F;npm&#x2F;（2）然后可以开始下载对应的node版本，推荐下载一个稳定版本和一个最新的版本下载最新版本直接执行指令nvm install latest就行了，稳定版本自己去官网找然后按nvm install 后面加版本号，例如nvm install 12.18.0 就能下载对应的node版本（3）输入 nvm ls，查看已安装的所有 node 版本。（4）输入 nvm -v，查看 已安装的 nvm 版本。（5）输入 node -v，查看正在使用的 node 版本。（6）输入nvm use 版本号即可切换对应的版本。 如输入命令nvm use 12.18.0后按nvm ls后node的版本前带有*号即代表当前使用的node版本（7）由于npm的下载地址为https://registry.npmjs.org/是国外服务器，国内很慢可以使用淘宝的镜像执行下面的命令即可123456&#x2F;&#x2F; 配置地址npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org&#x2F;&#x2F; 安装npm install&#x2F;&#x2F;设置为原来的地址npm config set registry https:&#x2F;&#x2F;registry.npmjs.org&#x2F;参考链接：安装npm，nvm，node如果 node 安装失败，可以参考上面这个链接再不行自己上网找。注册GitHubgithub点击GitHub中的New repository创建新仓库。仓库名为：你的用户名**.http://github.io 这是固定写法为了后面操作更简单，如我的因为我已经有了这个名字的仓库所以才有这个警告，直接创建仓库安装git（期间Git Bash Here窗口会弹窗要求你输入GitHub的账号密码输入即可）git真的是傻瓜式安装直接下一步下一步到了添加路径三选一选择的时候选择第二个Use Git from the Windows Command Prompt就行了直接自动帮你配置环境这些操作。在命令行输入git查看是否安装成功或者右击鼠标有以下显示点击Git Bash Here一一输入以下指令（git的终端的复制快捷键是ctrl+ins，粘贴的快捷键是shift+ins，停止终端命令都和别的终端命令一样是ctrl+c）1234git config --global user.name &quot;你的GitHub用户名&quot;git config --global user.email &quot;你的GitHub注册邮箱&quot;&#x2F;&#x2F;生成ssh密钥文件：ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot;然后会在你的C盘的用户下的.ssh会有这个文件，如可能那个known_hosts文件没有生成，不过不用管他，之后在Git Bash中执行某条指令是提示你缺少这个文件是否安装继续你就按yes就行，他自动帮你安装补全然后用word或者记事本之类的软件打开上面的红色框文件，然后ctrl+A全部复制，回到你的GitHub，点击右上角的GitHub后按setting，然后按左边栏的SSH and GPG keys，然后点击绿色按钮New SSH key，出现以下文本框这里的第一行title随便你填，把刚才的id_rsa.pub文本内容复制到key文本框，直接按绿色的按钮Add SSH key在Git Bash中输入1ssh -T git@github.com提示这个直接按yes之后提示你xx用户，你已经成功认证安装 Hexo这时我们在电脑里创建一个文件夹，可以命名为Blog，Hexo框架与以后你自己发布的网页都在这个文件夹中，然后在当前blog文件夹打开cmd，即进入blog文件夹可以按ctrl+L在任务栏输入cmd或者直接打开cmd后把blog文件夹拖拽到cmd窗口所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。（使用npm安装插件有时会出现黄色的WARN直接无视它不是ERRO就没事,下同）1npm install -g hexo-cli进阶安装和使用（推荐）对于熟悉 npm 的进阶用户，可以仅局部安装 hexo 包。12&#x2F;&#x2F;推荐局部安装npm install hexo安装完成后继续输入1hexo init blog然后一一输入以下指令12345hexo new firstBolg&#x2F;&#x2F;生成静态网页hexo g&#x2F;&#x2F;打开本地服务器hexo s然后浏览器打开http://localhost:4000/，这是我们就可以看到自己初步形成的静态网站博客了，时不时有了大功告成的感觉了Hexo与GitHub关联这一步我们实现将自己的网页部署到网上，网址是GitHub提供给我们的xxxx.github.io访问打开站点的配置文件_config.yml（即blog文件夹下的_config.yml），翻到最后修改为：1234deploy: type: git repository: 你的仓库地址(如我的是https:&#x2F;&#x2F;github.com&#x2F;xxydrr&#x2F;xxydrr.github.io) branch: master注意：deploy前面不要留空格，下面的三行话前面有两个空格。.yml的文件格式非常严格然后在blog文件夹下打开cmd（blog文件夹下按ctrl+L在地址栏输入cmd按Enter即可），安装一个插件1npm install hexo-deployer-git --save然后输入hexo new post &quot;article title&quot;，新建一篇文章。然后打开blog\\source\\_posts的目录，可以发现下面多了一个.md文件，就是你的文章文件。编写完markdown文件后，blog目录下右键打开git bash依次输入以下三条命令123hexo clean hexo g hexo d完成后，打开浏览器，在地址栏输入你的放置个人网站的仓库路径，即xxxx.github.io,你就会发现你的博客已经上线了，可以在网络上被访问了。绑定域名我们要自己的个性化域名，这就需要绑定我们自己的域名。这里演示腾讯云的域名绑定，在国内主流的域名代理厂商也就阿里云和腾讯云。还没有购买域名的小伙伴可能要等几天才能进行域名绑定操作，因为域名注册后还要实名给注册局注册才能用。不过你可以先跳到配置hexo和主题选择部分继续操作登录到腾讯云，进入管理控制台的域名列表，找到你的个性化域名，点击解析进入解释，参考我的简单介绍以下记录值192.30.252.153和192.30.252.154是GitHub的服务器地址，最后的主机类型www记录类型A记录值是你的github域名打开你的github博客项目，点击settings，拉到下面Custom domain处，填上你自己的域名，保存：然后进入blog/source目录下，创建一个记事本文件，输入你的域名。保存，命名为CNAME ，注意保存成所有文件即文件没有后缀然后在blog目录下右键打开git bash123hexo cleanhexo ghexo d这时候打开浏览器输入你的域名将会直接进入你自己搭建的网站。配置主题如果你不喜欢Hexo默认的主题，可以更换不同的主题，主题传送门：Themes 我自己使用的是pure。配置主题是非常复杂的事情，各个主题的源码不同配置方式也不同。因为首先你想要找到你自己喜欢的主题，然后点进去他的github下载源码到自己博客的themes文件夹下。因为每个人的审美不同，我自己的主题也是自己一步步配置的，找到自己喜欢的主题进去他的主题源码有个markdown文件教你怎么配置的了。在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。所以我总结的配置主题方法就是找到自己喜欢的主题然后打开他的说明markdown文档以及上作者主题的GitHub查看Issue看看别人出现问题怎么解决自己有没出现，也可以去hexo官方文档查看博客主题配置，这样才能配置出自己喜欢的主题，下面我总结以下通用主题的配置方式(1)添加背景动画在\\themes\\{你的主题名}\\layout\\layout.ejs的*&lt;/*body&gt;后中面添加(2)添加404页面在\\blog\\themes\\{你的主题名}\\source 下新建404.html文件，404文件的样式源码可以自己上网搜我的是404源码然后引入对应的css文件和images文件就行了(4)后台管理插件hexo-adminGithub：https://github.com/jaredly/hexo-admin简介：可以直接在网页端创建、编辑markdown文章内容，并将内容发布到_posts里。最方便的是可以很方便的给文章加标题、分类、打标签。配置按照它的官网操作进行了套Cloudflare简单说Cloudflare免费提供cdn服务即可以使你的网站访问加速，并且自定义域名提供免费的 https 服务而不会通过域名访问时显示网站不安全的提示。使用方式进入Cloudflare官网，然后填入个人域名选择免费套餐接着这一步如果你已经在域名服务商那里解析过域名的话，就会出现你域名的解析列表（下图是我的另一个域名没有解释）点击下一步 Cloudflare 会有非常详细的提示，回到域名管理删除默认的域名服务器替代为CloundFlare名称服务器几个小时后就能颁发证书成功，你可以登录Cloudflare看一下也可以打开自己的博客网站然后打开开发者工具按Network，点击左边的name对应的域名查看右边的Heders的server已经是cloudflare代表已经成功了第一篇博客编写博客编写建议使用现在主流的markdown形式，markdown软件建议使用Typora编写或者用你的编辑器写也行1hexo new &quot;hello blog&quot;输入这条命令后将会在blog\\source_posts文件夹下看到helloblog.md文T件，打开他的源代码形式是12345---title: hello blog //题目date: 2020-06-14 19:46:42 //时间tags: //标签---这是基本的文章配置，注意一定要按照这样的格式在开头编写文章的配置，更多的配置请参考自己对应的主题markdown说明文档补充。然后就可以编写文章了，下面是简单的markdown语法及其快捷键12345678910111213Typora快捷键整合Ctrl+1 一阶标题 Ctrl+B 字体加粗Ctrl+2 二阶标题 Ctrl+I 字体倾斜Ctrl+3 三阶标题 Ctrl+U 下划线Ctrl+4 四阶标题 Ctrl+Home 返回Typora顶部Ctrl+5 五阶标题 Ctrl+End 返回Typora底部Ctrl+6 六阶标题 Ctrl+T 创建表格Ctrl+L 选中某句话 Ctrl+K 创建超链接Ctrl+D 选中某个单词 Ctrl+F 搜索Ctrl+E 选中相同格式的文字 Ctrl+H 搜索并替换Alt+Shift+5 删除线 Ctrl+Shift+I 插入图片Ctrl+Shift+M 公式块 Ctrl+Shift+Q 引用注：一些实体符号需要在实体符号之前加”\\”才能够显示图床准备这里我推荐使用微博图床，下面看我的超级简单方法（1）安装这个浏览器插件新浪微博图床然后简直白嫖一样，点击插件然后在浏览器上登录自己的微博就能用了，图片不会存在自己微博的相册中也不会自动发微博啥的，然后点击这个插件还可以查看自己的历史图片然后拉进去就可以快乐插图片继续写文章了发布文章准备建议首先依次输入这三条指令本地查看一下先123456789hexo clean &#x2F;&#x2F;清除缓存文件 db.json 和已生成的静态文件 public网站显示异常时可以执行这条命令试试。hexo g &#x2F;&#x2F;生成网站静态文件到默认设置的 public 文件夹。 &#x2F;&#x2F;便于查看网站生成的静态文件或者手动部署网站；如果使用自动部署， &#x2F;&#x2F;不需要先执行该命令hexo g 是 hexo generate 的缩写，命令效果一致。hexo s &#x2F;&#x2F;启动本地服务器，用于预览主题。默认地址： http:&#x2F;&#x2F;localhost:4000&#x2F;hexo s 是 hexo server 的缩写， &#x2F;&#x2F;命令效果一致；预览的同时可以修改文章内容或主题代码，保存后刷新页面即可；对 Hexo 根目录 _config.yml 的修改， &#x2F;&#x2F;需要重启本地服务器后才能预览效果。感觉没问题后执行hexo d把它部署到自己的GitHub仓库中，接着我们就能在网上输入自己的域名查看效果了1hexo d &#x2F;&#x2F;自动生成网站静态文件，并部署到设定的仓库。hexo d 是 hexo deploy 的缩写，命令效果一致。之后我们常用的hexo组合指令是12hexo clean &amp;&amp; hexo shexo clean &amp;&amp; hexo d然后就大功告成了，谢谢阅读！","categories":[{"name":"hexo博客搭建","slug":"hexo博客搭建","permalink":"http://180231.xyz/categories/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://180231.xyz/tags/hexo/"},{"name":"GitHub","slug":"GitHub","permalink":"http://180231.xyz/tags/GitHub/"},{"name":"博客","slug":"博客","permalink":"http://180231.xyz/tags/%E5%8D%9A%E5%AE%A2/"}]}],"categories":[{"name":"vue","slug":"vue","permalink":"http://180231.xyz/categories/vue/"},{"name":"js设计模式","slug":"js设计模式","permalink":"http://180231.xyz/categories/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"hexo博客搭建","slug":"hexo博客搭建","permalink":"http://180231.xyz/categories/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://180231.xyz/tags/vue/"},{"name":"vue书写规范","slug":"vue书写规范","permalink":"http://180231.xyz/tags/vue%E4%B9%A6%E5%86%99%E8%A7%84%E8%8C%83/"},{"name":"css书写规范","slug":"css书写规范","permalink":"http://180231.xyz/tags/css%E4%B9%A6%E5%86%99%E8%A7%84%E8%8C%83/"},{"name":"面向对象","slug":"面向对象","permalink":"http://180231.xyz/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"设计模式","slug":"设计模式","permalink":"http://180231.xyz/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"类与继承","slug":"类与继承","permalink":"http://180231.xyz/tags/%E7%B1%BB%E4%B8%8E%E7%BB%A7%E6%89%BF/"},{"name":"hexo","slug":"hexo","permalink":"http://180231.xyz/tags/hexo/"},{"name":"GitHub","slug":"GitHub","permalink":"http://180231.xyz/tags/GitHub/"},{"name":"博客","slug":"博客","permalink":"http://180231.xyz/tags/%E5%8D%9A%E5%AE%A2/"}]}